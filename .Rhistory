# Run the annotation algorithm
Annot <- Annotation(Tree,plot=TRUE)
Annot$combinations
# Exemple of seeked phenotypes
# variable in which seeked phenotypes can be entered in the form
# of matrices.
phenotypes <- list()
# seeked phenotypes
phenotypes[[1]] <-  rbind(c("FL1", 0),
c("FL2", 1),
c("FL4", 0))
phenotypes[[2]] <-  rbind(c("FL1", 1),
c("FL2", 0),
c("FL4", 1))
phenotypes[[3]] <-  rbind(c("FL1", 1),
c("FL2", 1),
c("FL4", 1))
# Retreive cell populations found using Annotation
PhenoInfos <- RetrievePops(Annot, phenotypes)
PhenoInfos$phenotypesinfo
RetrievePops <-function(AnnotationObj, phenotypes)
{
if(class(AnnotationObj)!="Annotation")
{
stop("AnnotationObj must be of class Annotation")
}
if(class(phenotypes)=="list")
{
if(class(phenotypes[[1]])!="matrix")
{
stop("elements of phenotypes should be of class matrix")
}
}
else
{
stop("phenotypes should be of class list")
}
labels <- AnnotationObj$labels
labelmerge <- labels
combinations <- AnnotationObj$combinations
maxlab <- max(labels)
L <- length(phenotypes)
outlist <- list()
Prop <- combinations[,c("prop")]
for(l in 1:L)
{
browser()
outlist[[l]] <- list()
temp <- phenotypes[[l]]
tempcombinations <- combinations[,temp[,1]]
scores <- rowSums(t(apply(tempcombinations, 1,
FUN = function(x,y)
{
x == y
}
,y = as.numeric(temp[,2]))
))
tempres <- which(scores == nrow(temp))
if(!length(tempres))
{
outlist[[l]][["phenotype"]] <- apply(temp[,1:2],1,paste,collapse="-")
outlist[[l]][["proportion"]] <- NA
outlist[[l]][["Mergedlabels"]] <- NA
outlist[[l]][["Newlabel"]] <- NA
}
else
{
leaves <- combinations[,c("leaves")][tempres]
outlist[[l]][["phenotype"]] <- apply(temp[,1:2],1,paste,collapse="-")
outlist[[l]][["proportion"]] <- sum(Prop[tempres])
if(length(tempres)>1)
{
outlist[[l]][["Mergedlabels"]] <- leaves
outlist[[l]][["Newlabel"]] <- maxlab + 1
labelmerge[labels%in%leaves] <- maxlab + 1
maxlab <- maxlab + 1
}
else
{
outlist[[l]][["label"]] <- leaves
}
}
}
return(list("phenotypesinfo" = outlist, "Mergedleaves" = labelmerge))
}
PhenoInfos <- RetrievePops(Annot, phenotypes)
outlist[[l]] <- list()
temp <- phenotypes[[l]]
temp
temp[,1]
combinations
temp[,1]%in%colnames(combinations)
colnames(combinations)
colnames_combinations <- colnames(combinations)
temp[,1]%in%colnames_combinations
a =c(FALSE,TRUE)
any(!a)
any(!(temp[,1]%in%colnames_combinations))
inputest <- temp[,1]%in%colnames_combinations
inputest
paste("markers",paste(c(temp[as.logical(1-inputest)]),
collapse=", "),
"are not in the tree", sep = " ")
temp
temp[,1]
temp[as.logical(1-inputest),1]
colnames_combinations
temp[,1]
#' Retreive cell populations found using Annotation.
#'
#'@param AnnotationObj An object of class Annotation.
#'
#'@param phenotypes A list containing at least one element of class
#'matrix describing a seeked phenotype. Each matrix should have two
#'columns where the name of a used marked is associated to a value
#'chosen between 0, 1 and 2. 0 translates to -, 1 to + and 2 to ++.
#'
#'@return A \code{list} of two elements.
#'\itemize{
#'\item{\code{phenotypesinfo}}{ A \code{list} containing informations
#'about seeked populations.}
#'\item{\code{Mergedleaves}}{ The partitioning of the set of n cells
#'with potentially merged leaves.}
#'}
#'
#'@author Chariff Alkhassim
#'
#'@export
RetrievePops <-function(AnnotationObj, phenotypes)
{
if(class(AnnotationObj)!="Annotation")
{
stop("AnnotationObj must be of class Annotation")
}
if(class(phenotypes)=="list")
{
if(class(phenotypes[[1]])!="matrix")
{
stop("elements of phenotypes should be of class matrix")
}
}
else
{
stop("phenotypes should be of class list")
}
labels <- AnnotationObj$labels
labelmerge <- labels
combinations <- AnnotationObj$combinations
colnames_combinations <- colnames(combinations)
maxlab <- max(labels)
L <- length(phenotypes)
outlist <- list()
Prop <- combinations[,c("prop")]
for(l in 1:L)
{
outlist[[l]] <- list()
temp <- phenotypes[[l]]
inputest <- temp[,1]%in%colnames_combinations
if(any(!(inputest)))
{
wstr <- paste("markers",paste(c(temp[as.logical(1-inputest),1]),
collapse=", "),
"are not in the tree", sep = " ")
stop(wstr)
}
tempcombinations <- combinations[,temp[,1]]
scores <- rowSums(t(apply(tempcombinations, 1,
FUN = function(x,y)
{
x == y
}
,y = as.numeric(temp[,2]))
))
tempres <- which(scores == nrow(temp))
if(!length(tempres))
{
outlist[[l]][["phenotype"]] <- apply(temp[,1:2],1,paste,collapse="-")
outlist[[l]][["proportion"]] <- NA
outlist[[l]][["Mergedlabels"]] <- NA
outlist[[l]][["Newlabel"]] <- NA
}
else
{
leaves <- combinations[,c("leaves")][tempres]
outlist[[l]][["phenotype"]] <- apply(temp[,1:2],1,paste,collapse="-")
outlist[[l]][["proportion"]] <- sum(Prop[tempres])
if(length(tempres)>1)
{
outlist[[l]][["Mergedlabels"]] <- leaves
outlist[[l]][["Newlabel"]] <- maxlab + 1
labelmerge[labels%in%leaves] <- maxlab + 1
maxlab <- maxlab + 1
}
else
{
outlist[[l]][["label"]] <- leaves
}
}
}
return(list("phenotypesinfo" = outlist, "Mergedleaves" = labelmerge))
}
phenotypes[[1]] <-  rbind(c("FL1", 0),
c("FL2", 1),
c("FL4", 0))
phenotypes[[2]] <-  rbind(c("FL1", 1),
c("FL2", 0),
c("FL4", 1))
phenotypes[[3]] <-  rbind(c("FL1", 1),
c("FL2", 1),
c("FL3", 1))
PhenoInfos <- RetrievePops(Annot, phenotypes)
#' Retreive cell populations found using Annotation.
#'
#'@param AnnotationObj An object of class Annotation.
#'
#'@param phenotypes A list containing at least one element of class
#'matrix describing a seeked phenotype. Each matrix should have two
#'columns where the name of a used marked is associated to a value
#'chosen between 0, 1 and 2. 0 translates to -, 1 to + and 2 to ++.
#'
#'@return A \code{list} of two elements.
#'\itemize{
#'\item{\code{phenotypesinfo}}{ A \code{list} containing informations
#'about seeked populations.}
#'\item{\code{Mergedleaves}}{ The partitioning of the set of n cells
#'with potentially merged leaves.}
#'}
#'
#'@author Chariff Alkhassim
#'
#'@export
RetrievePops <-function(AnnotationObj, phenotypes)
{
if(class(AnnotationObj)!="Annotation")
{
stop("AnnotationObj must be of class Annotation")
}
if(class(phenotypes)=="list")
{
if(class(phenotypes[[1]])!="matrix")
{
stop("elements of phenotypes should be of class matrix")
}
}
else
{
stop("phenotypes should be of class list")
}
labels <- AnnotationObj$labels
labelmerge <- labels
combinations <- AnnotationObj$combinations
colnames_combinations <- colnames(combinations)
maxlab <- max(labels)
L <- length(phenotypes)
outlist <- list()
Prop <- combinations[,c("prop")]
for(l in 1:L)
{
outlist[[l]] <- list()
temp <- phenotypes[[l]]
inputest <- temp[,1]%in%colnames_combinations
if(any(!(inputest)))
{
logicalinds <- as.logical(1-inputest)
if(sum(logicalinds) > 1)
{
wstr <- paste("markers",paste(c(temp[logicalinds,1]),
collapse=", "),
"are not in the tree", sep = " ")
}
else
{
wstr <- paste("marker",paste(c(temp[logicalinds,1]),
collapse=", "),
"is not in the tree", sep = " ")
}
stop(wstr)
}
tempcombinations <- combinations[,temp[,1]]
scores <- rowSums(t(apply(tempcombinations, 1,
FUN = function(x,y)
{
x == y
}
,y = as.numeric(temp[,2]))
))
tempres <- which(scores == nrow(temp))
if(!length(tempres))
{
outlist[[l]][["phenotype"]] <- apply(temp[,1:2],1,paste,collapse="-")
outlist[[l]][["proportion"]] <- NA
outlist[[l]][["Mergedlabels"]] <- NA
outlist[[l]][["Newlabel"]] <- NA
}
else
{
leaves <- combinations[,c("leaves")][tempres]
outlist[[l]][["phenotype"]] <- apply(temp[,1:2],1,paste,collapse="-")
outlist[[l]][["proportion"]] <- sum(Prop[tempres])
if(length(tempres)>1)
{
outlist[[l]][["Mergedlabels"]] <- leaves
outlist[[l]][["Newlabel"]] <- maxlab + 1
labelmerge[labels%in%leaves] <- maxlab + 1
maxlab <- maxlab + 1
}
else
{
outlist[[l]][["label"]] <- leaves
}
}
}
return(list("phenotypesinfo" = outlist, "Mergedleaves" = labelmerge))
}
PhenoInfos <- RetrievePops(Annot, phenotypes)
PhenoInfos$phenotypesinfo
PhenoInfos <- RetrievePops(Annot, phenotypes)
phenotypes[[1]] <-  rbind(c("FL1", 0),
c("FL2", 1),
c("FL4", 0))
phenotypes[[2]] <-  rbind(c("FL1", 1),
c("FL2", 0),
c("FL4", 1))
phenotypes[[3]] <-  rbind(c("FL1", 1),
c("FL2", 1),
c("FL4", 1))
PhenoInfos <- RetrievePops(Annot, phenotypes)
PhenoInfos$phenotypesinfo
phenotypes[[1]] <-  rbind(c("FL10", 0),
c("FL2", 1),
c("FL4", 0))
phenotypes[[2]] <-  rbind(c("FL1", 1),
c("FL2", 0),
c("FL40", 1))
phenotypes[[3]] <-  rbind(c("FL1", 1),
c("FL2", 1),
c("FL4", 1))
PhenoInfos <- RetrievePops(Annot, phenotypes)
phenotypes[[1]] <-  rbind(c("FL10", 0),
c("FL2", 1),
c("FL40", 0))
phenotypes[[2]] <-  rbind(c("FL1", 1),
c("FL2", 0),
c("FL40", 1))
phenotypes[[3]] <-  rbind(c("FL1", 1),
c("FL2", 1),
c("FL4", 1))
PhenoInfos <- RetrievePops(Annot, phenotypes)
phenotypes[[1]] <-  rbind(c("FL1", 0),
c("FL2", 1),
c("FL4", 0))
phenotypes[[2]] <-  rbind(c("FL1", 1),
c("FL2", 0),
c("FL4", 1))
phenotypes[[3]] <-  rbind(c("FL1", 1),
c("FL2", 1),
c("FL4", 1))
# Retreive cell populations found using Annotation
PhenoInfos <- RetrievePops(Annot, phenotypes)
PhenoInfos$phenotypesinfo
#' Plot the distribution of the observed cells at each node
#' of the binary tree built using CytomeTree.
#'
#'@param CytomeTreeObj An object of class CytomeTree.
#'
#'@param nodes A vector of class character containing the name of
#'nodes for which the distribution is to be plotted. Default is
#'\code{NULL}, and plots the distribution of each node.
#'
#'@author Chariff Alkhassim
#'
#'@export
#
plot_nodes <- function(CytomeTreeObj, nodes=NULL)
{
if(class(CytomeTreeObj) != "CytomeTree")
{
stop("CytomeTreeObj must be of class CytomeTree")
}
if(!is.null(nodes))
{
if(class(nodes)!="character")
{
stop("nodes must be of class character")
}
}
pl_list <- CytomeTreeObj$pl_list
if(is.null(nodes))
{
nn<- length(pl_list[[1]])
for (n in 1:nn)
{
minxinf <- min(pl_list[[1]][[n]]$x)
minxsup <- min(pl_list[[3]][[n]]$x)
maxxinf <- max(pl_list[[1]][[n]]$x)
maxxsup <- max(pl_list[[3]][[n]]$y)
minyinf <- min(pl_list[[1]][[n]]$y)
minysup <- min(pl_list[[3]][[n]]$y)
maxyinf <- max(pl_list[[1]][[n]]$y)
maxysup <- max(pl_list[[3]][[n]]$y)
plot(pl_list[[3]][[n]],
xlim=c(min(c(minxinf, minxsup)), max(c(maxxinf, maxxsup))),
ylim=c(min(c(minyinf, minysup)), max(c(maxyinf, maxysup))),
yaxt = 'n',
main =pl_list[[2]][[n]],
xlab = pl_list[[4]][[n]],
ylab = "Density",
col = "blue", lwd=2, type="l")
lines(pl_list[[1]][[n]], col='red', lwd = 2)
}
}
else
{
treenodes <- unlist(pl_list[[2]])
if(sum(nodes%in%treenodes)!=length(nodes))
{
logicalind <- as.logical(1-nodes%in%treenodes)
if(length(logicalind) >1)
{
wstr <- paste("nodes",paste(c(nodes[]),
collapse=", "),
"are not in the tree", sep = " ")
}
else
{
wstr <- paste("node",paste(c(nodes[]),
collapse=", "),
"is not in the tree", sep = " ")
}
stop(wstr)
}
inds <- which(treenodes%in%nodes)
for(ind in inds)
{
df <- data.frame("x1" = pl_list[[3]][[ind]]$x,
"y1" = pl_list[[3]][[ind]]$y,
"x2" = pl_list[[1]][[ind]]$x,
"y2" = pl_list[[1]][[ind]]$y,
"Marker" = paste0(pl_list[[2]][[ind]],
"\n", pl_list[[4]][[ind]]),
"colx1" = as.factor(rep(1,length(pl_list[[3]][[ind]]))),
"colx2" = as.factor(rep(2,length(pl_list[[3]][[ind]]))))
p <- ggplot(df, aes_string(x = "x1", y = "y1",colour = "colx1")) +
geom_line(lwd = 1)+
geom_line(data = df, aes_string(x = "x2", y = "y2", colour = "colx2"),
lwd = 1)+
scale_colour_manual(name = "",
values = c("blue","red"),
labels = c("GM", "KDE"))+
facet_wrap(~ Marker)+
theme_bw()+
ylab("Density")+
xlab("Fluorescence")+
theme(legend.position="bottom",
axis.text.y=element_blank(),
axis.ticks.y=element_blank())
print(p)
}
}
}
phenotypes[[1]] <-  rbind(c("FL1", 0),
c("FL2", 1),
c("FL4", 0))
phenotypes[[2]] <-  rbind(c("FL1", 1),
c("FL2", 0),
c("FL4", 1))
phenotypes[[3]] <-  rbind(c("FL1", 1),
c("FL2", 1),
c("FL4", 1))
PhenoInfos <- RetrievePops(Annot, phenotypes)
PhenoInfos$phenotypesinfo
plot_nodes(Tree,"FL4.10")
plot_nodes(Tree,c("FL4.10", "FL4.100"))
plot_nodes(Tree,"FL4.1")
plot_nodes(Tree,"FL4.1")
library(cytometree)
library(cytometree)
head(DLBCL)
# number of cell event
N <- nrow(DLBCL)
# Build the binary tree with t = .1
Tree <- CytomeTree(DLBCL, minleaf = 1 ,t=.1)
# Plot node distributions
par(mfrow=c(1,2))
plot_nodes(Tree)
# Choose a node to plot
plot_nodes(Tree,"FL4.1")
# Plot a graph of the tree
par(mfrow=c(1,1))
plot_graph(Tree,edge.arrow.size=.3, Vcex =.5, vertex.size = 30)
# Run the annotation algorithm
Annot <- Annotation(Tree,plot=TRUE)
Annot$combinations
# Exemple of seeked phenotypes
# variable in which seeked phenotypes can be entered in the form
# of matrices.
phenotypes <- list()
# seeked phenotypes
phenotypes[[1]] <-  rbind(c("FL1", 0),
c("FL2", 1),
c("FL4", 0))
phenotypes[[2]] <-  rbind(c("FL1", 1),
c("FL2", 0),
c("FL4", 1))
phenotypes[[3]] <-  rbind(c("FL1", 1),
c("FL2", 1),
c("FL4", 1))
# Retreive cell populations found using Annotation
PhenoInfos <- RetrievePops(Annot, phenotypes)
PhenoInfos$phenotypesinfo
library(cytometree)
library(cytometree)
