---
title: "User guide for automatic gating with cytometree"
author: "Chariff Alkhassim, Boris Hejblum"
date: "`r Sys.Date()`"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r knitrsetup, include=FALSE}
knitr::knit_hooks$set(small.mar = function(before, options, envir) {
    if (before) par(mar = c(0, 0, 0, 0))  # no margin
})
```



# Introduction to `cytometree`

`cytometree` is a package that implements a binary tree algorithm for the analysis of cytometry data.

Its core algorithm is based on the construction of a binary tree, whose nodes represents 
cell subpopulations.

## Binary tree construction

1. At each node, observed cells (or "events") and markers are modeled by both a normal distribution (so *unimodal*), and a mixture of 2 normal distributions (so *bimodal*).

2. Splitting of the events at each node is done according to a normalized difference of AIC between 
the two distributional fit (unimodal or bimodal), allowing to pick the marker that best splits those data.

3. When AIC noralized differences $D$ are not significant anymore, the tree has been constructed, and the cells have been automatically gated (i.e. partitioned). 

## Post-hoc annotation

Given the unsupervised nature of the binary tree, some of the available markers may not be used to find the different cell populations present in a given sample. To recover a complete annotation, we defined, as a post processing procedure, an annotation method which allows the user to distinguish two (or three) expression levels per marker.


# Example of an analysis with `cytometree`

## Automatic gating step

In this example, we will use a diffuse large B-cell lymphoma dataset (from the [flowCAP-I challenge](http://flowcap.flowsite.org/), with only 3 markers. First, we need to load the package `cytometree` and we can have a look at the data:

```{r, message=FALSE}
library(cytometree)
dim(DLBCL)
head(DLBCL)
```
We have 3 markers measured `FL1`, `FL2`, `FL4` as well as the `label` obtained from manual gating, and `r nrow(DLBCL)` cell.

```{r}
# getting the only the cell events with the 3 markers measured:
cellevents <- DLBCL[,c("FL1", "FL2", "FL4")]
# storing the maanual gating reference from FlowCAP-I:
manual_labels <- DLBCL[,"label"]
```

The function `CytomeTree` builds the binary tree according to our algorithm, that gives the automatic gating (given in the resulting `labels` attribute):
```{r, message=FALSE}
# Build the binary tree:
Tree <- CytomeTree(cellevents, minleaf = 1, t = 0.1)
# Retreive the resulting partition (i.e. automatic gating):
Tree_Partition <- Tree$labels
```
One can fiddle with the `t` threshold to change the desired depth of the tree.

The function `plot_graph` plots a graph representing this binary tree, showing which markers were used in which order to splits the events:
```{r, fig.width = 4, fig.height=4, small.mar=TRUE}
# Plot a graph of the tree (with specific graphical parameters):
plot_graph(Tree, edge.arrow.size = 0.3, Vcex = 0.8, vertex.size = 30)
```

The function `plot_nodes` allows to graphically evaluate the fit of the gaussian family distribution at each node. It can also be used to investigate a particular node:
```{r}
# Plot node distributions.
plot_nodes(Tree)
# Choose a particular node to plot
plot_nodes(Tree, "FL4.1")
```


## Post-processing annotation of automatically gated subpopulations

The function `Annotation` annotates the subpopulations partitionned by the binary tree:

```{r}
# Run the annotation algorithm.
Annot <- Annotation(Tree,plot=FALSE)
Annot$combinations
```

The post-procesing annotation can be compared to the uncomplete annotation obtained from the tree alone:
```{r}
# Compare to the annotation gotten from the tree.
Tree$annotation
```

This completed annotation eases the search for specific cell types of interest, where `1` represents a postive measurement of a marker, while `0` corresponds to its absence:
```{r}

# seeked cell type: FL1+FL2+FL4+.
pheno_ex1 <- RetrievePops(Annot, phenotypes = list(rbind(c("FL1", 1), c("FL2", 1), c("FL4", 1))))
pheno_ex1$phenotypesinfo

#One can look for several cell types at once:
phenotypes <- list()
# FL1-FL2+FL4-
phenotypes[[1]] <- rbind(c("FL1", 0), c("FL2", 1), c("FL4", 0))
# FL1+FL2-FL4+
phenotypes[[2]] <- rbind(c("FL1", 1), c("FL2", 0), c("FL4", 1))
# Retreive corresponding cell populations:
PhenoInfos <- RetrievePops(Annot, phenotypes)
PhenoInfos$phenotypesinfo
```

## Comparison between manual and automatic gating

Finally, we can compare the automatic gating obtained using `cytometree` to the original manual gating (which had `r sum(manual_labels==0)` events unconsitantly gated accross different operators performing the manual gating on those very same data - so those `r sum(manual_labels==0)` cells were identified as outliers in the reference label and were kept out of the evaluation criteria in the [flowCAP-I challenge](http://flowcap.flowsite.org/)):

```{r, echo=FALSE, small.mar=TRUE, fig.width=6.5, fig.height=4}
# F-measure ignoring cells labeled 0 as in FlowCAP-I.
# Use FmeasureC() in any other case.
Fmeas <- FmeasureC_no0(ref=manual_labels, pred=Tree_Partition)
# Scatterplots.
library(ggplot2)
# Ignoring cells labeled 0 as in FlowCAP-I.
# Building the data frame to scatter plot the data.
FL1 <- cellevents[, "FL1"]
FL2 <- cellevents[, "FL2"]
FL4 <- cellevents[, "FL4"]
n <- length(FL1)

man_lab <- factor(as.character(manual_labels))
levels(man_lab) <- c("outliers (manual gating)", "pop1", "pop2")
auto_lab <- factor(as.character(Tree_Partition))
levels(auto_lab) <- c("pop2", "pop1", "pop3 (autogating only)")
Labels <- factor(c(as.character(man_lab), as.character(auto_lab)))

method <- as.factor(c(rep("FlowCap-I manual gating", n), rep("CytomeTree auto gating", n)))
scatter_df <- data.frame("FL2" = FL2, "FL4" = FL4, "Label" = Labels, "method" = method)

p <- ggplot2::ggplot(scatter_df,  ggplot2::aes_string(x = "FL2", y="FL4",colour="Label"))+
 ggplot2::geom_point(alpha = 1,cex = 1)+ 
 ggplot2::scale_colour_manual(values = c("grey", viridis::viridis(3))) +
 ggplot2::facet_wrap(~ method) +
 ggplot2::theme_bw() +
 ggplot2::theme(legend.position="bottom") +
 ggplot2::guides(colour = ggplot2::guide_legend(override.aes = list(size=3)))+
 ggplot2::ggtitle(paste("F-measure (manual gating as reference - removing the outliers) =", round(Fmeas, 3)))
p
```
