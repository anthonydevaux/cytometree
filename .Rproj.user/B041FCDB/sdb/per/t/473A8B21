{
    "collab_server" : "",
    "contents" : "# Slice Sampling of the Dirichlet Process Mixture Model\n# with a prior on alpha\n# \n# \n# @param z data matrix \\code{d x n} with \\code{d} dimensions in rows \n# and \\code{n} observations in columns.\n# \n# @param hyperG0 prior mixing distribution.\n# \n# @param a shape hyperparameter of the Gamma prior \n# on the parameter of the Dirichlet Process.\n# \n# @param b scale hyperparameter of the Gamma prior \n# on the parameter of the Dirichlet Process.\n# \n# @param N number of MCMC iterations.\n# \n# @param doPlot logical flag indicating wether to plot MCMC iteration or not.\n# Default to \\code{TRUE}.\n# \n# @param nbclust_init number of clusters at initialisation. \n# Default to 30 (or less if there are less than 30 observations).\n# \n# @param diagVar logical flag indicating wether the variance of each cluster is \n# estimated as a diagonal matrix, or as a full matrix. \n# Default is \\code{TRUE} (diagonal variance).\n# \n# @param verbose logical flag indicating wether partition info is \n# written in the console at each MCMC iteration.\n# \n# @author Chariff Alkhassim\n# \n# @export \n\n\n\n\n# CytomeTree <- function(data,plot=FALSE, minleaf)\n# {\n#   n <- nrow(data)\n#   p <- ncol(data)\n#   if(minleaf>=n){stop(\"minleaf >= ncells\")}\n#   combinations <- matrix(NA,n,p)   \n#   col_names <- colnames(data)\n#   colnames(combinations) <- col_names\n#   level <- 1\n#   tree <- list()\n#   racine <- list()\n#   marker_tree <- list()\n#   markers_left <- list()\n#   rootmarkers <- list()\n#   labels <- rep(0,n)\n#   label_counter <- 1\n#   EmIclRes <- EmIcl(data,indices = 1:n,minleaf)\n#   if(is.null(EmIclRes$ind))\n#   {\n#     labels <- rep(1,n)\n#     Tree <- list(\"tree\"=NULL,\"marker_tree\"=NULL,\n#                  \"combinations\"=NULL,\"labels\"=labels)\n#     class(Tree) <- \"CyTree\"\n#     return(Tree)\n#   }\n#   root_ind <- EmIclRes$ind[1]\n#   marker_left <- c(EmIclRes$ind[-c(1)], EmIclRes$mark_not_dis)\n#   #   marker_left <- 1:p\n#   racine[[level]] <- data[,root_ind] \n#   tree[[level]] <- racine\n#   marker_tree[[level]] <- root_ind\n#   plot(density(data[,root_ind]), main = col_names[root_ind])\n#   rootmarkers[[level]] <- marker_left\n#   markers_left[[level]] <- rootmarkers \n#   levelMAX <- 1000 \n#   while(levelMAX)\n#   {\n#     levelMAX <- levelMAX - 1\n#     son_level <- level + 1\n#     tree[[son_level]] <- list()\n#     markers_left[[son_level]] <- list()\n#     n_nodes_at_level <- try(length(tree[[level]]),TRUE)\n#     #     if(inherits(n_nodes_at_level, \"try-error\")){\n#     #       Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#     #                    \"combinations\"=combinations,\"labels\"=labels)\n#     #       class(Tree) <- \"CyTree\"\n#     #       return(Tree)\n#     #     }\n#     stopping_flag <- 0\n#     node_counter <- 1\n#     for (i in 1:n_nodes_at_level)\n#     {\n#       if(level == 4){browser()}\n# #       flag_marker_left <- 1\n#       flag_son <- 0\n#       temp_node <- tree[[level]][[i]]\n#     \n#       marker_left <- markers_left[[level]][[i]]\n#       flag_marker_left <- length(marker_left)\n#       #       marker_left <- 1:p\n#       if(level==1)\n#       {\n#         flag_son <- 1\n#         L_son <- EmIclRes$son$G\n#         R_son <- EmIclRes$son$D\n#         combinations[L_son,root_ind] <- 0\n#         combinations[R_son,root_ind] <- 1\n#         \n#       }\n#       else\n#       {\n#         if(!length(marker_left))\n#         {\n#           \n#           \n#           stopping_flag <- stopping_flag + 1\n#           node_counter <- node_counter + 2\n#           \n#           if(length(temp_node)){\n#             \n#             if(names(table(labels[temp_node]))!= \"0\" | \n#                  length(table(labels[temp_node])) > 1 \n#             ){browser()} \n#             \n#             labels[temp_node] <- label_counter\n#             label_counter <- label_counter + 1 \n#           }\n#           \n#           \n#           if(stopping_flag==n_nodes_at_level)\n#           {            \n#             Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                          \"combinations\"=combinations,\"labels\"=labels)\n#             class(Tree) <- \"CyTree\"\n#             return(Tree)\n#           }\n#         }\n#         else\n#         {\n#           EmIclRes <- EmIcl(data[temp_node,marker_left],\n#                             indices = temp_node,minleaf)\n#           if(is.null(EmIclRes$ind))\n#           {\n#             marker_tree[[level]][[i]] <- NA\n#             stopping_flag <- stopping_flag + 1\n#             node_counter <- node_counter + 2\n#             \n#             #             if(is.null(temp_node)){browser()}\n#             #             \n#             #             if((names(table(labels[temp_node]))!= \"0\" | \n#             #                   length(table(labels[temp_node])) > 1 \n#             #                   )){browser()} \n#             #             \n#             #             #             if(label_counter == 9){browser()}\n#             #             labels[temp_node] <- label_counter\n#             #             label_counter <- label_counter + 1\n#             \n#             if(is.null(temp_node)){browser()}\n#           \n#               labels[temp_node] <- label_counter\n#               label_counter <- label_counter + 1\n#             \n#             if(stopping_flag==n_nodes_at_level)\n#             {            \n#               Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                            \"combinations\"=combinations,\"labels\"=labels)\n#               class(Tree) <- \"CyTree\"\n#               return(Tree)\n#             }\n#           }\n#           else\n#           {\n#             ind <- marker_left[EmIclRes$ind[1]]\n#             plot(density(data[temp_node,ind]), main = col_names[ind])\n#             \n#             marker_tree[[level]][[i]] <- ind\n#             temp_mar_res <- c(EmIclRes$ind[-c(1)],\n#                               EmIclRes$mark_not_dis)\n#             marker_left <- marker_left[temp_mar_res]\n# #             marker_left <- 1:p\n#             flag_marker_left <- length(marker_left)\n#             flag_son <- 1\n#             L_son <- EmIclRes$son$G\n#             R_son <- EmIclRes$son$D\n#             combinations[L_son,ind] <- 0\n#             combinations[R_son,ind] <- 1\n#           } \n#         }\n#       }\n#       if(flag_son)\n#       { \n#         temp_list_ls <- list()\n#         temp_list_rs <- list()\n#         temp_list_ls[[1]] <- L_son\n#         temp_list_rs[[1]] <- R_son\n#         tree[[son_level]][node_counter] <- temp_list_ls\n#         tree[[son_level]][node_counter + 1] <- temp_list_rs\n#         if(flag_marker_left)\n#         {\n#           markers_left[[son_level]][[node_counter]] <- marker_left\n#           markers_left[[son_level]][[node_counter + 1]] <- marker_left\n#         }\n#         else\n#         { \n#           markers_left[[son_level]][[node_counter]] <- numeric(0)\n#           markers_left[[son_level]][[node_counter + 1]] <- numeric(0)\n#         }\n#         node_counter <- node_counter + 2\n#       }\n#     }\n#     level <- son_level\n#     marker_tree[[son_level]] <- list()\n#   }\n#   Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                \"combinations\"=combinations,\"labels\"=labels)\n#   class(Tree) <- \"CyTree\"\n#   return(Tree)\n# }\n\n# \n# \n# CytomeTree <- function(data,plot=FALSE, minleaf)\n# {\n#   n <- nrow(data)\n#   p <- ncol(data)\n#   if(minleaf>=n){stop(\"minleaf >= ncells\")}\n#   combinations <- matrix(NA,n,p)   \n#   col_names <- colnames(data)\n#   colnames(combinations) <- col_names\n#   level <- 1\n#   tree <- list()\n#   racine <- list()\n#   marker_tree <- list()\n#   markers_left <- list()\n#   rootmarkers <- list()\n#   plot_list <- list()\n#   labels <- rep(0,n)\n#   label_counter <- 1\n#   label_graph <- 1\n#   EmIclRes <- EmIcl(data,indices = 1:n,minleaf,level=1, ancestry= NULL)\n#   if(is.null(EmIclRes$ind))\n#   {\n#     labels <- rep(1,n)\n#     Tree <- list(\"tree\"=NULL,\"marker_tree\"=NULL,\n#                  \"combinations\"=NULL,\"labels\"=labels,\n#                  \"plot_list\"= plot_list)\n#     class(Tree) <- \"CyTree\"\n#     return(Tree)\n#   }\n#   root_ind <- EmIclRes$ind[1]\n#   marker_left <- c(EmIclRes$ind[-c(1)], EmIclRes$mark_not_dis)\n#   #   marker_left <- 1:p\n#   racine[[level]] <- data[,root_ind] \n#   tree[[level]] <- racine\n#   marker_tree[[level]] <- paste0(col_names[root_ind],\".\",label_graph)\n#   if(plot)\n#   {\n#     plot(density(data[,root_ind]), main = paste0(col_names[root_ind],\".\",label_graph)) \n#   }\n#   plot_list[[1]] <- list()\n#   plot_list[[1]][[label_graph]] <- density(data[,root_ind])\n#   plot_list[[2]] <- list()\n#   plot_list[[2]][[label_graph]] <- paste0(col_names[root_ind],\".\",label_graph)\n#   rootmarkers[[level]] <- marker_left\n#   markers_left[[level]] <- rootmarkers \n#   levelMAX <- 1000 \n#   while(levelMAX)\n#   {\n#     levelMAX <- levelMAX - 1\n#     son_level <- level + 1\n#     tree[[son_level]] <- list()\n#     markers_left[[son_level]] <- list()\n#     n_nodes_at_level <- try(length(tree[[level]]),TRUE)\n#     \n#     \n#     \n#     \n#     stopping_flag <- 0\n#     node_counter <- 1\n#     for (i in 1:n_nodes_at_level)\n#     {\n#       # label_graph <- label_graph + 1\n#       flag_pop <- 0\n#       flag_son <- 0\n#       temp_node <- tree[[level]][[i]]\n#       \n#       marker_left <- markers_left[[level]][[i]]\n#       flag_marker_left <- length(marker_left)\n#       #       marker_left <- 1:p\n#       if(level==1)\n#       {\n#         flag_son <- 1\n#         L_son <- EmIclRes$son$G\n#         R_son <- EmIclRes$son$D\n#         combinations[L_son,root_ind] <- 0\n#         combinations[R_son,root_ind] <- 1\n#         \n#       }\n#       else\n#       {\n#         if(!length(marker_left))\n#         {\n#           \n#           # marker_tree[[level]][[i]] <- NA\n#           stopping_flag <- stopping_flag + 1\n#           # node_counter <- node_counter + 2\n#           \n#           if(!is.na(temp_node[1]) & length(temp_node)){\n#             \n#             if(names(table(labels[temp_node]))!= \"0\" | \n#                  length(table(labels[temp_node])) > 1 \n#             ){browser()} \n#             flag_pop <- 1\n#             labels[temp_node] <- label_counter\n#             \n#           }\n#           if(flag_pop)\n#           {\n#             marker_tree[[level]][[i]] <- as.character(label_counter) \n#             label_counter <- label_counter + 1\n#           }\n#           else\n#           {\n#             marker_tree[[level]][[i]] <- NA   \n#           }\n#           if(stopping_flag==n_nodes_at_level)\n#           {            \n#             Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                          \"combinations\"=combinations,\"labels\"=labels,\n#                          \"plot_list\"= plot_list)\n#             class(Tree) <- \"CyTree\"\n#             return(Tree)\n#           }\n#         }\n#         else\n#         {\n#           if(i%%2)\n#           {\n#             ancestry <- NULL \n#           }\n#           else\n#           {\n#             if(i==2)\n#             {\n#               indl <- 1\n#             }\n#             else\n#             {\n#               indl <- i/2 \n#             }\n#             ancestry <- list()\n#             if(level == 2)\n#             {\n#               ancestry$marker <- marker_tree[[(level - 1)]][[indl]]\n#               ancestry$data <-  tree[[(level - 1)]][[indl]] \n#             }\n#             else\n#             {\n#               ancestry$marker <- marker_tree[[(level - 1)]][[indl]]\n# #               ancestry$data <-  data[tree[[(level - 1)]][[indl]],\n# #                                      substr(ancestry$marker, 1, \n# #                                             nchar(ancestry$marker)-2)]\n# #               \n#               \n#               \n#               ancestry$data <-  try(data[tree[[(level - 1)]][[indl]],\n#                                          substr(ancestry$marker, 1, \n#                                                 nchar(ancestry$marker)-2)],\n#                                     silent = TRUE)\n#               \n#               \n#               if(inherits(ancestry$data,\"try-error\"))\n#               {\n#                 ancestry$data <-data[tree[[(level - 1)]][[indl]],\n#                                      substr(ancestry$marker, 1, \n#                                             nchar(ancestry$marker)-3)] \n#               }\n#               \n#               \n#               \n#               \n#             }\n#           }\n#           \n# \n#           \n#           EmIclRes <- EmIcl(data[temp_node,marker_left],\n#                             indices = temp_node,minleaf, level = level,\n#                             ancestry = ancestry)\n#           if(is.null(EmIclRes$ind))\n#           {\n#             # marker_tree[[level]][[i]] <- NA\n#             stopping_flag <- stopping_flag + 1\n#             # node_counter <- node_counter + 2\n#             \n#             \n#             if(is.null(temp_node)){browser()}\n#             flag_pop <- 1\n#             labels[temp_node] <- label_counter\n#             \n#             \n#             \n#             if(flag_pop)\n#             {\n#               marker_tree[[level]][[i]] <- as.character(label_counter) \n#               label_counter <- label_counter + 1\n#             }\n#             else\n#             {\n#               marker_tree[[level]][[i]] <- NA   \n#             }\n#             \n#             if(stopping_flag==n_nodes_at_level)\n#             {            \n#               Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                            \"combinations\"=combinations,\"labels\"=labels,\n#                            \"plot_list\"= plot_list)\n#               class(Tree) <- \"CyTree\"\n#               return(Tree)\n#             }\n#           }\n#           else\n#           {\n#             label_graph <- label_graph + 1\n#             ind <- marker_left[EmIclRes$ind[1]]\n#             if(plot)\n#             {\n#               plot(density(data[temp_node,ind]), main = paste0(col_names[ind],\".\",label_graph))\n#               \n#             }\n#             \n#             plot_list[[1]][[label_graph]] <- density(data[temp_node,ind])\n#             plot_list[[2]][[label_graph]] <- paste0(col_names[ind],\".\",label_graph)\n#             marker_tree[[level]][[i]] <- paste0(col_names[ind],\".\",label_graph)\n#             temp_mar_res <- c(EmIclRes$ind[-c(1)],\n#                               EmIclRes$mark_not_dis)\n#             marker_left <- marker_left[temp_mar_res]\n#             #             marker_left <- 1:p\n#             flag_marker_left <- length(marker_left)\n#             flag_son <- 1\n#             L_son <- EmIclRes$son$G\n#             R_son <- EmIclRes$son$D\n#             combinations[L_son,ind] <- 0\n#             combinations[R_son,ind] <- 1\n#           } \n#         }\n#       }\n#       if(flag_son)\n#       { \n#         temp_list_ls <- list()\n#         temp_list_rs <- list()\n#         temp_list_ls[[1]] <- L_son\n#         temp_list_rs[[1]] <- R_son\n#         tree[[son_level]][node_counter] <- temp_list_ls\n#         tree[[son_level]][node_counter + 1] <- temp_list_rs\n#         if(flag_marker_left)\n#         {\n#           markers_left[[son_level]][[node_counter]] <- marker_left\n#           markers_left[[son_level]][[node_counter + 1]] <- marker_left\n#         }\n#         else\n#         { \n#           markers_left[[son_level]][[node_counter]] <- numeric(0)\n#           markers_left[[son_level]][[node_counter + 1]] <- numeric(0)\n#           \n#         }\n#         node_counter <- node_counter + 2\n#       }\n#       else\n#       {\n#         temp_list_ls <- list()\n#         temp_list_rs <- list()\n#         temp_list_ls[[1]] <- NA\n#         temp_list_rs[[1]] <- NA\n#         tree[[son_level]][node_counter] <- temp_list_ls\n#         tree[[son_level]][node_counter + 1] <- temp_list_rs\n#         \n#         \n#         markers_left[[son_level]][[node_counter]] <- numeric(0)\n#         markers_left[[son_level]][[node_counter + 1]] <- numeric(0)\n#         \n#         \n#         node_counter <- node_counter + 2\n#       }\n#     }\n#     level <- son_level\n#     marker_tree[[son_level]] <- list()\n#   }\n#   Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                \"combinations\"=combinations,\"labels\"=labels,\n#                \"plot_list\"= plot_list)\n#   class(Tree) <- \"CyTree\"\n#   return(Tree)\n# }\n\n# Slice Sampling of the Dirichlet Process Mixture Model\n# with a prior on alpha\n# \n# \n# @param z data matrix \\code{d x n} with \\code{d} dimensions in rows \n# and \\code{n} observations in columns.\n# \n# @param hyperG0 prior mixing distribution.\n# \n# @param a shape hyperparameter of the Gamma prior \n# on the parameter of the Dirichlet Process.\n# \n# @param b scale hyperparameter of the Gamma prior \n# on the parameter of the Dirichlet Process.\n# \n# @param N number of MCMC iterations.\n# \n# @param doPlot logical flag indicating wether to plot MCMC iteration or not.\n# Default to \\code{TRUE}.\n# \n# @param nbclust_init number of clusters at initialisation. \n# Default to 30 (or less if there are less than 30 observations).\n# \n# @param diagVar logical flag indicating wether the variance of each cluster is \n# estimated as a diagonal matrix, or as a full matrix. \n# Default is \\code{TRUE} (diagonal variance).\n# \n# @param verbose logical flag indicating wether partition info is \n# written in the console at each MCMC iteration.\n# \n# @author Chariff Alkhassim\n# \n# @export \n\n\n# CytomeTree <- function(data,plot=FALSE, minleaf, Split, distr)\n# {\n#   n <- nrow(data)\n#   p <- ncol(data)\n#   if(minleaf>=n)\n#   {\n#     stop(\"minleaf >= ncells\")\n#   }\n#   combinations <- matrix(NA,n,p)   \n#   col_names <- colnames(data)\n#   colnames(combinations) <- col_names\n#   level <- 1\n#   tree <- list()\n#   racine <- list()\n#   marker_tree <- list()\n#   markers_left <- list()\n#   rootmarkers <- list()\n#   labels <- rep(0,n)\n#   label_counter <- 1\n#   \n#   NodeSplitRes <- NodeSplit(data, Kexpr=2, indices = 1:n, minleaf,\n#                             Split, distr, overwrite = \"FALSE\")\n#   if(NodeSplitRes$nSons == 1)\n#   {\n#     labels <- rep(1,n)\n#     Tree <- list(\"tree\"=NULL,\"marker_tree\"=NULL,\n#                  \"combinations\"=NULL,\"labels\"=labels)\n#     class(Tree) <- \"CyTree\"\n#     return(Tree)\n#   }\n#   root_ind <- NodeSplitRes$winMar \n#   racine[[level]] <- data[,root_ind] \n#   tree[[level]] <- racine\n#   marker_tree[[level]] <- root_ind\n#   plot(density(data[,root_ind]))\n#   rootmarkers[[level]] <- NodeSplitRes$markers_left\n#   markers_left[[level]] <- rootmarkers \n#   levelMAX <- p**2  #TODO\n#   while(levelMAX)\n#   {\n#     levelMAX <- levelMAX - 1\n#     son_level <- level + 1\n#     tree[[son_level]] <- list()\n#     markers_left[[son_level]] <- list()\n#     n_nodes_at_level <- length(tree[[level]])\n#     stopping_flag <- 0\n#     node_counter <- 1\n#     for (i in 1:n_nodes_at_level)\n#     {\n#       flag_marker_left <- 1\n#       flag_son <- 0\n#       temp_node <- tree[[level]][[i]]\n#       n_cells <- length(temp_node)\n#       marker_left <- markers_left[[level]][[i]]\n#       if(level==1)\n#       {\n#         flag_son <- 1\n#         # TODO K sons \n#         L_son <- NodeSplitRes$Sons[[1]]\n#         R_son <- NodeSplitRes$Sons[[2]]\n#         combinations[L_son,root_ind] <- 0\n#         combinations[R_son,root_ind] <- 1\n#       }\n#       else\n#       {\n#         \n#         minleafinternal <- 1\n#         if(!length(marker_left) | n_cells <= minleafinternal |\n#              n_cells <= minleaf)\n#         {\n#           stopping_flag <- stopping_flag + 1\n#           node_counter <- node_counter + 2\n#           labels[temp_node] <- label_counter\n#           label_counter <- label_counter + 1\n#         }\n#         else\n#         {\n#           NodeSplitRes <- NodeSplit(data[temp_node,marker_left], Kexpr = 2,\n#                                     indices = temp_node, minleaf, Split, \n#                                     distr, overwrite = \"FALSE\")\n#           if(NodeSplitRes$nSons == 1)\n#           {\n#             stopping_flag <- stopping_flag + 1\n#             node_counter <- node_counter + 2\n#             labels[temp_node] <- label_counter\n#             label_counter <- label_counter + 1\n#           }\n#           else{\n#             ind <- NodeSplitRes$winMar\n#             plot(density(data[,ind]))\n#             marker_tree[[level]][[i]] <- ind\n#             marker_left <- marker_left[NodeSplitRes$markers_left]\n#             flag_marker_left <- length(marker_left)  # TOREMOVE\n#             flag_son <- 1                           # TOREMOVE\n#             # TODO K sons\n#             #             L_son <- NodeSplitRes$Sons[[1]]\n#             #             R_son <- NodeSplitRes$Sons[[2]]\n#             #             combinations[L_son,ind] <- 0\n#             #             combinations[R_son,ind] <- 1\n#           } \n#         }\n#         if(stopping_flag == n_nodes_at_level)\n#         {            \n#           Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                        \"combinations\"=combinations,\"labels\"=labels)\n#           class(Tree) <- \"CyTree\"\n#           return(Tree)\n#         }\n#       }\n#       if(flag_son)\n#       { \n#         temp_list_ls <- list()\n#         temp_list_rs <- list()\n#         temp_list_ls[[1]] <- L_son\n#         temp_list_rs[[1]] <- R_son\n#         Nsons <- length(NodeSplitRes$Sons)\n#         for (ii in 1:Nsons)\n#         {\n#           #           browser()\n#           sony <- NodeSplitRes$Sons[[ii]]\n#           tree[[son_level]][[node_counter + (ii-1)]] <- sony\n#         }\n#         \n#         #         tree[[son_level]][node_counter] <- temp_list_ls\n#         #         tree[[son_level]][node_counter + 1] <- temp_list_rs\n#         if(flag_marker_left)\n#         {\n#           for(ii in 1:Nsons)\n#           {\n#             markers_left[[son_level]][[node_counter + (ii-1)]] <- marker_left\n#           }\n#           #           markers_left[[son_level]][[node_counter]] <- marker_left\n#           #           markers_left[[son_level]][[node_counter + 1]] <- marker_left\n#         }else\n#         {\n#           labels[temp_node] <- label_counter\n#           label_counter <- label_counter + 1\n#           for(ii in 1:Nsons)\n#           {\n#             markers_left[[son_level]][[node_counter + (ii-1)]] <- numeric(0)\n#             \n#             #           markers_left[[son_level]][[node_counter]] <- numeric(0)\n#             #           markers_left[[son_level]][[node_counter + 1]] <- numeric(0)\n#           }\n#           #         node_counter <- node_counter + 2\n#           \n#         }\n#         node_counter <- node_counter + Nsons\n# #         browser()\n#       }\n#       level <- son_level\n#       marker_tree[[son_level]] <- list()\n#     }\n#     \n#   }\n#   Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                \"combinations\"=combinations,\"labels\"=labels)\n#   class(Tree) <- \"CyTree\"\n#   return(Tree)\n# }\n\n\n\n\n\n# Slice Sampling of the Dirichlet Process Mixture Model\n# with a prior on alpha\n# \n# \n# @param z data matrix \\code{d x n} with \\code{d} dimensions in rows \n# and \\code{n} observations in columns.\n# \n# @param hyperG0 prior mixing distribution.\n# \n# @param a shape hyperparameter of the Gamma prior \n# on the parameter of the Dirichlet Process.\n# \n# @param b scale hyperparameter of the Gamma prior \n# on the parameter of the Dirichlet Process.\n# \n# @param N number of MCMC iterations.\n# \n# @param doPlot logical flag indicating wether to plot MCMC iteration or not.\n# Default to \\code{TRUE}.\n# \n# @param nbclust_init number of clusters at initialisation. \n# Default to 30 (or less if there are less than 30 observations).\n# \n# @param diagVar logical flag indicating wether the variance of each cluster is \n# estimated as a diagonal matrix, or as a full matrix. \n# Default is \\code{TRUE} (diagonal variance).\n# \n# @param verbose logical flag indicating wether partition info is \n# written in the console at each MCMC iteration.\n# \n# @author Chariff Alkhassim\n# \n# @export \n\n\n\n\n# CytomeTree <- function(data,plot=FALSE, minleaf){\n#   n <- nrow(data)\n#   p <- ncol(data)\n#   if(minleaf>=n){stop(\"minleaf >= ncells\")}\n#   combinations <- matrix(NA,n,p)   \n#   col_names <- colnames(data)\n#   colnames(combinations) <- col_names\n#   level <- 1\n#   tree <- list()\n#   racine <- list()\n#   marker_tree <- list()\n#   markers_left <- list()\n#   rootmarkers <- list()\n#   labels <- rep(0,n)\n#   label_counter <- 1\n#   EmIclRes <- EmIcl(data,indices = 1:n,minleaf)\n#   if(is.null(EmIclRes$ind)){\n#     labels <- rep(1,n)\n#     Tree <- list(\"tree\"=NULL,\"marker_tree\"=NULL,\n#                  \"combinations\"=NULL,\"labels\"=labels)\n#     class(Tree) <- \"CyTree\"\n#     return(Tree)\n#   }\n#   root_ind <- EmIclRes$ind[1]\n#   marker_left <- c(EmIclRes$ind[-c(1)], EmIclRes$mark_not_dis)\n#   #   marker_left <- 1:p\n#   racine[[level]] <- data[,root_ind] \n#   tree[[level]] <- racine\n#   marker_tree[[level]] <- root_ind\n#   plot(density(data[,root_ind]), main = col_names[root_ind])\n#   rootmarkers[[level]] <- marker_left\n#   markers_left[[level]] <- rootmarkers \n#   levelMAX <- p**2 \n#   while(levelMAX){\n#     levelMAX <- levelMAX - 1\n#     son_level <- level + 1\n#     tree[[son_level]] <- list()\n#     markers_left[[son_level]] <- list()\n#     n_nodes_at_level <- try(length(tree[[level]]),TRUE)\n#     #     if(inherits(n_nodes_at_level, \"try-error\")){\n#     #       Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#     #                    \"combinations\"=combinations,\"labels\"=labels)\n#     #       class(Tree) <- \"CyTree\"\n#     #       return(Tree)\n#     #     }\n#     stopping_flag <- 0\n#     node_counter <- 1\n#     for (i in 1:n_nodes_at_level){\n#       flag_marker_left <- 1\n#       flag_son <- 0\n#       temp_node <- tree[[level]][[i]]\n#       marker_left <- markers_left[[level]][[i]]\n#       #       marker_left <- 1:p\n#       if(level==1){\n#         flag_son <- 1\n#         L_son <- EmIclRes$son$G\n#         R_son <- EmIclRes$son$D\n#         combinations[L_son,root_ind] <- 0\n#         combinations[R_son,root_ind] <- 1\n#       }\n#       else{\n#         \n#         if(!length(marker_left)){\n#           \n#           \n#           stopping_flag <- stopping_flag + 1\n#           node_counter <- node_counter + 2\n#           \n#           #           if(!is.null(temp_node))\n#           #           {\n#           #             if((names(table(labels[temp_node]))!= \"0\" | \n#           #                   length(table(labels[temp_node])) > 1)){browser()} \n#           #           }\n#           #           \n#           \n#           labels[temp_node] <- label_counter\n#           label_counter <- label_counter + 1\n#           \n#           \n#           if(stopping_flag==n_nodes_at_level){            \n#             Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                          \"combinations\"=combinations,\"labels\"=labels)\n#             class(Tree) <- \"CyTree\"\n#             return(Tree)\n#           }\n#         }else{\n#           EmIclRes <- EmIcl(data[temp_node,marker_left],\n#                             indices = temp_node,minleaf)\n#           if(is.null(EmIclRes$ind)){\n#             stopping_flag <- stopping_flag + 1\n#             node_counter <- node_counter + 2\n#             \n#             #           if(!is.null(temp_node))\n#             #           {\n#             #             if((names(table(labels[temp_node]))!= \"0\" | \n#             #                   length(table(labels[temp_node])) > 1)){browser()} \n#             #           }\n#             #           \n#             \n#             labels[temp_node] <- label_counter\n#             label_counter <- label_counter + 1\n#             \n#             \n#             if(stopping_flag==n_nodes_at_level){            \n#               Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                            \"combinations\"=combinations,\"labels\"=labels)\n#               class(Tree) <- \"CyTree\"\n#               return(Tree)\n#             }\n#           }\n#           else{\n#             ind <- marker_left[EmIclRes$ind[1]]\n#             plot(density(data[temp_node,ind]), main = col_names[ind])\n#             \n#             marker_tree[[level]][[i]] <- ind\n#             temp_mar_res <- c(EmIclRes$ind[-c(1)],\n#                               EmIclRes$mark_not_dis)\n#             marker_left <- marker_left[temp_mar_res]\n#             #           marker_left <- 1:p\n#             flag_marker_left <- length(marker_left)\n#             flag_son <- 1\n#             L_son <- EmIclRes$son$G\n#             R_son <- EmIclRes$son$D\n#             combinations[L_son,ind] <- 0\n#             combinations[R_son,ind] <- 1\n#           }\n#           \n#         }\n#         \n#         if(is.null(EmIclRes$ind)){\n#           stopping_flag <- stopping_flag + 1\n#           node_counter <- node_counter + 2\n#           \n#           \n#           labels[temp_node] <- label_counter\n#           label_counter <- label_counter + 1\n#           \n#           \n#           if(stopping_flag==n_nodes_at_level){            \n#             Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                          \"combinations\"=combinations,\"labels\"=labels)\n#             class(Tree) <- \"CyTree\"\n#             return(Tree)\n#           }\n#         }\n#         else{\n#           ind <- marker_left[EmIclRes$ind[1]]\n#           plot(density(data[temp_node,ind]), main = col_names[ind])\n#           \n#           marker_tree[[level]][[i]] <- ind\n#           temp_mar_res <- c(EmIclRes$ind[-c(1)],\n#                             EmIclRes$mark_not_dis)\n#           marker_left <- marker_left[temp_mar_res]\n#           #           marker_left <- 1:p\n#           flag_marker_left <- length(marker_left)\n#           flag_son <- 1\n#           L_son <- EmIclRes$son$G\n#           R_son <- EmIclRes$son$D\n#           combinations[L_son,ind] <- 0\n#           combinations[R_son,ind] <- 1\n#         }\n#       }\n#       if(flag_son){ \n#         temp_list_ls <- list()\n#         temp_list_rs <- list()\n#         temp_list_ls[[1]] <- L_son\n#         temp_list_rs[[1]] <- R_son\n#         tree[[son_level]][node_counter] <- temp_list_ls\n#         tree[[son_level]][node_counter + 1] <- temp_list_rs\n#         if(flag_marker_left){\n#           markers_left[[son_level]][[node_counter]] <- marker_left\n#           markers_left[[son_level]][[node_counter + 1]] <- marker_left\n#         }else{\n#           #           labels[temp_node] <- label_counter\n#           #           label_counter <- label_counter + 1\n#           markers_left[[son_level]][[node_counter]] <- numeric(0)\n#           markers_left[[son_level]][[node_counter + 1]] <- numeric(0)\n#         }\n#         node_counter <- node_counter + 2\n#       }\n#       #       else{next}\n#     }\n#     level <- son_level\n#     marker_tree[[son_level]] <- list()\n#   }\n#   Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                \"combinations\"=combinations,\"labels\"=labels)\n#   class(Tree) <- \"CyTree\"\n#   return(Tree)\n# }\n# \n# \n# \n# #\n\n\n\n\n\n\n# \n# CytomeTree <- function(data,plot=FALSE, minleaf, Split, distr)\n# {\n#   n <- nrow(data)\n#   p <- ncol(data)\n#   if(minleaf>=n)\n#   {\n#     stop(\"minleaf >= ncells\")\n#   }\n#   combinations <- matrix(NA,n,p)   \n#   col_names <- colnames(data)\n#   colnames(combinations) <- col_names\n#   level <- 1\n#   tree <- list()\n#   racine <- list()\n#   marker_tree <- list()\n#   markers_left <- list()\n#   rootmarkers <- list()\n#   labels <- rep(0,n)\n#   label_counter <- 1\n#   \n#   NodeSplitRes <- NodeSplit(data, Kexpr=2, indices = 1:n, minleaf,\n#                             Split, distr, overwrite = \"FALSE\")\n#   if(NodeSplitRes$nSons == 1)\n#   {\n#     labels <- rep(1,n)\n#     Tree <- list(\"tree\"=NULL,\"marker_tree\"=NULL,\n#                  \"combinations\"=NULL,\"labels\"=labels)\n#     class(Tree) <- \"CyTree\"\n#     return(Tree)\n#   }\n#   root_ind <- NodeSplitRes$winMar \n#   racine[[level]] <- data[,root_ind] \n#   tree[[level]] <- racine\n#   marker_tree[[level]] <- root_ind\n#   plot(density(data[,root_ind]))\n#   rootmarkers[[level]] <- NodeSplitRes$markers_left\n#   markers_left[[level]] <- rootmarkers \n#   levelMAX <- p**2  #TODO\n#   while(levelMAX)\n#   {\n#     levelMAX <- levelMAX - 1\n#     son_level <- level + 1\n#     tree[[son_level]] <- list()\n#     markers_left[[son_level]] <- list()\n#     n_nodes_at_level <- length(tree[[level]])\n#     stopping_flag <- 0\n#     node_counter <- 1\n#     for (i in 1:n_nodes_at_level)\n#     {\n#       flag_marker_left <- 1\n#       flag_son <- 0\n#       temp_node <- tree[[level]][[i]]\n#       n_cells <- length(temp_node)\n#       marker_left <- markers_left[[level]][[i]]\n#       if(level==1)\n#       {\n#         flag_son <- 1\n#         # TODO K sons \n#         L_son <- NodeSplitRes$Sons[[1]]\n#         R_son <- NodeSplitRes$Sons[[2]]\n#         combinations[L_son,root_ind] <- 0\n#         combinations[R_son,root_ind] <- 1\n#       }\n#       else\n#       {\n#         \n#         minleafinternal <- 1\n#         if(!length(marker_left) | n_cells <= minleafinternal |\n#              n_cells <= minleaf)\n#         {\n#           stopping_flag <- stopping_flag + 1\n#           node_counter <- node_counter + 2\n#           labels[temp_node] <- label_counter\n#           label_counter <- label_counter + 1\n#         }\n#         else\n#         {\n#           NodeSplitRes <- NodeSplit(data[temp_node,marker_left], Kexpr = 2,\n#                                     indices = temp_node, minleaf, Split, \n#                                     distr, overwrite = \"FALSE\")\n#           if(NodeSplitRes$nSons == 1)\n#           {\n#             stopping_flag <- stopping_flag + 1\n#             node_counter <- node_counter + 2\n#             labels[temp_node] <- label_counter\n#             label_counter <- label_counter + 1\n#           }\n#           else{\n#             ind <- NodeSplitRes$winMar\n#             plot(density(data[,ind]))\n#             marker_tree[[level]][[i]] <- ind\n#             marker_left <- marker_left[NodeSplitRes$markers_left]\n#             flag_marker_left <- length(marker_left)  # TOREMOVE\n#             flag_son <- 1                           # TOREMOVE\n#             # TODO K sons\n#             L_son <- NodeSplitRes$Sons[[1]]\n#             R_son <- NodeSplitRes$Sons[[2]]\n#             combinations[L_son,ind] <- 0\n#             combinations[R_son,ind] <- 1\n#           } \n#         }\n#         if(stopping_flag == n_nodes_at_level)\n#         {            \n#           Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                        \"combinations\"=combinations,\"labels\"=labels)\n#           class(Tree) <- \"CyTree\"\n#           return(Tree)\n#         }\n#       }\n#       if(flag_son)\n#       { \n#         temp_list_ls <- list()\n#         temp_list_rs <- list()\n#         temp_list_ls[[1]] <- L_son\n#         temp_list_rs[[1]] <- R_son\n#         \n#         tree[[son_level]][node_counter] <- temp_list_ls\n#         tree[[son_level]][node_counter + 1] <- temp_list_rs\n#         if(flag_marker_left)\n#         {\n#           markers_left[[son_level]][[node_counter]] <- marker_left\n#           markers_left[[son_level]][[node_counter + 1]] <- marker_left\n#         }else\n#         {\n#           labels[temp_node] <- label_counter\n#           label_counter <- label_counter + 1\n#           markers_left[[son_level]][[node_counter]] <- numeric(0)\n#           markers_left[[son_level]][[node_counter + 1]] <- numeric(0)\n#         }\n#         node_counter <- node_counter + 2\n#       }\n#     }\n#     level <- son_level\n#     marker_tree[[son_level]] <- list()\n#   }\n#   Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n#                \"combinations\"=combinations,\"labels\"=labels)\n#   class(Tree) <- \"CyTree\"\n#   return(Tree)\n# }\n\n\nCytomeTree <- function(data,plot=FALSE, minleaf)\n{\n  n <- nrow(data)\n  p <- ncol(data)\n  if(minleaf>=n){stop(\"minleaf >= ncells\")}\n  combinations <- matrix(NA,n,p)   \n  col_names <- colnames(data)\n  colnames(combinations) <- col_names\n  level <- 1\n  Signtree <- list()\n  tree <- list()\n  racine <- list()\n  marker_tree <- list()\n  markers_left <- list()\n  rootmarkers <- list()\n  plot_list <- list()\n  labels <- rep(0,n)\n  label_counter <- 1\n  label_graph <- 1\n  EmIclRes <- EmIcl(data,indices = 1:n,minleaf,level=1)\n  if(is.null(EmIclRes$ind))\n  {\n    labels <- rep(1,n)\n    Tree <- list(\"tree\"=NULL,\"marker_tree\"=NULL,\n                 \"combinations\"=NULL,\"labels\"=labels,\n                 \"plot_list\"= plot_list, \"Signtree\" = Signtree)\n    class(Tree) <- \"CyTree\"\n    return(Tree)\n  }\n  root_ind <- EmIclRes$ind[1]\n  marker_left <- c(EmIclRes$ind[-c(1)], EmIclRes$mark_not_dis)\n  #   marker_left <- 1:p\n  racine[[level]] <- data[,root_ind] \n  tree[[level]] <- racine\n  Signtree[[level]] <- \"root\"\n  marker_tree[[level]] <- paste0(col_names[root_ind],\".\",label_graph)\n  if(plot)\n  {\n\n    pl1 <- curve(GaussMix(x, EmIclRes$mu1, EmIclRes$mu2, \n             sqrt(EmIclRes$Var1), sqrt(EmIclRes$Var2),\n             EmIclRes$pi1, EmIclRes$pi2), \n          xlim=c(min(density(data[,root_ind])$x),max(density(data[,root_ind])$x)),\n          main = paste0(col_names[root_ind],\".\",label_graph),\n          xlab = paste(\"N = \", length(data[,root_ind]),\", normICL = \",\n                       round(EmIclRes$entropie[1],2), sep =\" \"),ylab = \"Density\",\n          col = \"blue\", lwd=2)\n    \n    \n    lines(density(data[,root_ind]), col='red', lwd = 2)\n  \n  }\n  plot_list[[1]] <- list()\n  plot_list[[1]][[label_graph]] <- density(data[,root_ind])\n  plot_list[[2]] <- list()\n  plot_list[[2]][[label_graph]] <- paste0(col_names[root_ind],\".\",label_graph)\n  plot_list[[3]] <- list()\n  plot_list[[3]][[label_graph]] <- pl1\n  plot_list[[4]] <- list()\n  plot_list[[4]][[label_graph]] <- paste(\"N = \", length(data[,root_ind]),\", normICL = \",\n                                         round(EmIclRes$entropie[1],2), sep =\" \")\n  \n  \n  \n\n  rootmarkers[[level]] <- marker_left\n  markers_left[[level]] <- rootmarkers \n  levelMAX <- 1000 \n  while(levelMAX)\n  {\n    levelMAX <- levelMAX - 1\n    son_level <- level + 1\n    tree[[son_level]] <- list()\n    Signtree[[son_level]] <- list()\n    markers_left[[son_level]] <- list()\n    n_nodes_at_level <- try(length(tree[[level]]),TRUE)\n    \n    stopping_flag <- 0\n    node_counter <- 1\n    for (i in 1:n_nodes_at_level)\n    {\n      # label_graph <- label_graph + 1\n      flag_pop <- 0\n      flag_son <- 0\n      temp_node <- tree[[level]][[i]]\n      \n      marker_left <- markers_left[[level]][[i]]\n      flag_marker_left <- length(marker_left)\n      #       marker_left <- 1:p\n      if(level==1)\n      {\n        flag_son <- 1\n        L_son <- EmIclRes$son$G\n        R_son <- EmIclRes$son$D\n        combinations[L_son,root_ind] <- 0\n        combinations[R_son,root_ind] <- 1\n        \n      }\n      else\n      {\n        if(!length(marker_left))\n        {\n          \n          # marker_tree[[level]][[i]] <- NA\n          stopping_flag <- stopping_flag + 1\n          # node_counter <- node_counter + 2\n          \n          if(!is.na(temp_node[1]) & length(temp_node)){\n            \n            if(names(table(labels[temp_node]))!= \"0\" | \n                 length(table(labels[temp_node])) > 1 \n            ){browser()} \n            flag_pop <- 1\n            labels[temp_node] <- label_counter\n            \n          }\n          if(flag_pop)\n          {\n            marker_tree[[level]][[i]] <- as.character(label_counter) \n            label_counter <- label_counter + 1\n          }\n          else\n          {\n            marker_tree[[level]][[i]] <- NA   \n          }\n          if(stopping_flag==n_nodes_at_level)\n          {            \n            Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n                         \"combinations\"=combinations,\"labels\"=labels,\n                         \"plot_list\"= plot_list, \"Signtree\" = Signtree)\n            class(Tree) <- \"CyTree\"\n            return(Tree)\n          }\n        }\n        else\n        {\n          \n          EmIclRes <- EmIcl(data[temp_node,marker_left],\n                            indices = temp_node,minleaf, level = level)\n          if(is.null(EmIclRes$ind))\n          {\n            # marker_tree[[level]][[i]] <- NA\n            stopping_flag <- stopping_flag + 1\n            # node_counter <- node_counter + 2\n            \n            \n            if(is.null(temp_node)){browser()}\n            flag_pop <- 1\n            labels[temp_node] <- label_counter\n            \n            \n            \n            if(flag_pop)\n            {\n              marker_tree[[level]][[i]] <- as.character(label_counter) \n              label_counter <- label_counter + 1\n            }\n            else\n            {\n              marker_tree[[level]][[i]] <- NA   \n            }\n            \n            if(stopping_flag==n_nodes_at_level)\n            {            \n              Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n                           \"combinations\"=combinations,\"labels\"=labels,\n                           \"plot_list\"= plot_list, \"Signtree\" = Signtree)\n              class(Tree) <- \"CyTree\"\n              return(Tree)\n            }\n          }\n          else\n          {\n            label_graph <- label_graph + 1\n            ind <- marker_left[EmIclRes$ind[1]]\n            if(plot)\n            {\n          \n              \n              pl <- curve(GaussMix(x, EmIclRes$mu1, EmIclRes$mu2, \n                             sqrt(EmIclRes$Var1), sqrt(EmIclRes$Var2),\n                             EmIclRes$pi1, EmIclRes$pi2), \n                    xlim=c(min(density(data[temp_node,ind])$x),max(density(data[temp_node,ind])$x)),\n                    main = paste0(col_names[ind],\".\",label_graph),\n                    xlab = paste(\"N = \", length(data[temp_node,ind]),\", normICL = \",\n                                 round(EmIclRes$entropie[1],2), sep =\" \"),ylab = \"Density\",\n                    col = \"blue\", lwd=2)\n              \n              lines(density(data[temp_node,ind]), col='red', lwd = 2)\n              \n              # plot(density(data[temp_node,ind]), main = paste0(col_names[ind],\".\",label_graph),\n              #      xlab = paste(\"N = \", length(data[temp_node,ind]),\n              #                   \", normICL = \",\n              #                   round(EmIclRes$entropie[1],2), sep =\" \"))\n              \n            }\n            \n            plot_list[[1]][[label_graph]] <- density(data[temp_node,ind])\n            plot_list[[2]][[label_graph]] <- paste0(col_names[ind],\".\",label_graph)\n            \n            \n         \n            plot_list[[3]][[label_graph]] <- pl\n\n            plot_list[[4]][[label_graph]] <- paste(\"N = \", length(data[temp_node,ind]),\", normICL = \",\n                                                   round(EmIclRes$entropie[1],2), sep =\" \")\n            \n            \n            \n            \n            \n            marker_tree[[level]][[i]] <- paste0(col_names[ind],\".\",label_graph)\n            temp_mar_res <- c(EmIclRes$ind[-c(1)],\n                              EmIclRes$mark_not_dis)\n            marker_left <- marker_left[temp_mar_res]\n            #             marker_left <- 1:p\n            flag_marker_left <- length(marker_left)\n            flag_son <- 1\n            L_son <- EmIclRes$son$G\n            R_son <- EmIclRes$son$D\n            \n            if(mean(data[,col_names[ind]]) < mean(data[L_son,col_names[ind]]))\n            {\n              combinations[L_son,ind] <- 1\n              combinations[R_son,ind] <- 2\n            }\n            else\n            {\n              combinations[L_son,ind] <- 0\n              combinations[R_son,ind] <- 1 \n            }\n          } \n        }\n      }\n      if(flag_son)\n      { \n        temp_list_ls <- list()\n        temp_list_rs <- list()\n        temp_list_ls[[1]] <- L_son\n        temp_list_rs[[1]] <- R_son\n        \n        tree[[son_level]][node_counter] <- temp_list_ls\n        tree[[son_level]][node_counter + 1] <- temp_list_rs\n        \n        \n        \n        temp_list_ls_sign <- list()\n        temp_list_rs_sign <- list()\n        \n        \n        if(level >1)\n        {\n          if(mean(data[,col_names[ind]]) < mean(data[L_son,col_names[ind]]))\n          {\n            \n            temp_list_ls_sign[[1]] <- \"+\"\n            temp_list_rs_sign[[1]] <- \"++\"\n            \n          }\n          else\n          {\n            temp_list_ls_sign[[1]] <- \"-\"\n            temp_list_rs_sign[[1]] <- \"+\"\n            \n          }\n        }\n        else\n        {\n          temp_list_ls_sign[[1]] <- \"-\"\n          temp_list_rs_sign[[1]] <- \"+\"\n        }\n        Signtree[[son_level]][node_counter] <- temp_list_ls_sign\n        Signtree[[son_level]][node_counter + 1] <- temp_list_rs_sign\n        \n        if(flag_marker_left)\n        {\n          markers_left[[son_level]][[node_counter]] <- marker_left\n          markers_left[[son_level]][[node_counter + 1]] <- marker_left\n        }\n        else\n        { \n          markers_left[[son_level]][[node_counter]] <- numeric(0)\n          markers_left[[son_level]][[node_counter + 1]] <- numeric(0)\n          \n        }\n        node_counter <- node_counter + 2\n      }\n      else\n      {\n        temp_list_ls <- list()\n        temp_list_rs <- list()\n        temp_list_ls[[1]] <- NA\n        temp_list_rs[[1]] <- NA\n        tree[[son_level]][node_counter] <- temp_list_ls\n        tree[[son_level]][node_counter + 1] <- temp_list_rs\n        \n        \n        \n        temp_list_ls_sign <- list()\n        temp_list_rs_sign <- list()\n        temp_list_ls_sign[[1]] <- NA\n        temp_list_rs_sign[[1]] <- NA\n        Signtree[[son_level]][node_counter] <- temp_list_ls_sign[[1]]\n        Signtree[[son_level]][node_counter + 1] <- temp_list_rs_sign[[1]]\n        \n        \n        markers_left[[son_level]][[node_counter]] <- numeric(0)\n        markers_left[[son_level]][[node_counter + 1]] <- numeric(0)\n        \n        \n        node_counter <- node_counter + 2\n      }\n    }\n    level <- son_level\n    marker_tree[[son_level]] <- list()\n  }\n  Tree <- list(\"tree\"=tree,\"marker_tree\"=marker_tree,\n               \"combinations\"=combinations,\"labels\"=labels,\n               \"plot_list\"= plot_list, \"Signtree\" = Signtree)\n  class(Tree) <- \"CyTree\"\n  return(Tree)\n}",
    "created" : 1477131034744.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1904459",
    "id" : "473A8B21",
    "lastKnownWriteTime" : 1479037299,
    "last_content_update" : 1479037299322,
    "path" : "~/Cytometree/R/CytomeTree.R",
    "project_path" : "R/CytomeTree.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}