{
    "collab_server" : "",
    "contents" : "#'Slice Sampling of the Dirichlet Process Mixture Model\n#'with a prior on alpha\n#'\n#'\n#'@param z data matrix \\code{d x n} with \\code{d} dimensions in rows \n#'and \\code{n} observations in columns.\n#'\n#'@param hyperG0 prior mixing distribution.\n#'\n#'@param a shape hyperparameter of the Gamma prior \n#'on the parameter of the Dirichlet Process.\n#'\n#'@param b scale hyperparameter of the Gamma prior \n#'on the parameter of the Dirichlet Process.\n#'\n#'@param N number of MCMC iterations.\n#'\n#'@param doPlot logical flag indicating wether to plot MCMC iteration or not.\n#'Default to \\code{TRUE}.\n#'\n#'@param nbclust_init number of clusters at initialisation. \n#'Default to 30 (or less if there are less than 30 observations).\n#'\n#'@param diagVar logical flag indicating wether the variance of each cluster is \n#'estimated as a diagonal matrix, or as a full matrix. \n#'Default is \\code{TRUE} (diagonal variance).\n#'\n#'@param verbose logical flag indicating wether partition info is \n#'written in the console at each MCMC iteration.\n#'\n#'@author Chariff Alkhassim\n#'\n#'\n#'@export \n#'\n\n\n# EmIcl <- function(data, indices,minleaf){\n#   mclust.options(warn=FALSE)\n#   data <- as.matrix(data)\n#   p <- ncol(data)\n#   n <- nrow(data)\n#   Minleaf <- 5\n#   if(n <= Minleaf | n < minleaf){\n#     mark_not_dis <- 1:p\n#     return(list(\"entropie\"=NULL,\"ind\"=NULL,\"mark_not_dis\"=mark_not_dis,\n#                 \"son\" = NULL))\n#   }\n#   ResIcl <- c()\n#   son <- list()\n#   ind_marker <- c()\n#   mark_not_dis <- c()\n#   \n#   for(j in 1:p){\n#     \n#     data_j <- data[,j]\n#     mu <- mean(data_j)\n#     Sigma <- var(data_j)\n#     \n#     mc_uni <- Mclust(data_j, 1)\n#                        \n#     # mc_uni <- Mclust(data_j, 1) \n#     flag_uni <- 0\n#     flag_dir <- 0\n#     #     mc <- Mclust(data_j, 2, modelNames = \"V\")\n#   \n#     mc <- Mclust(data_j, 2)\n#     \n#     #     \n#     #         ind1 <-which(mc$classification == 1)\n#     #         ind2 <-which(mc$classification == 2)\n#     \n#     sortdata <- sort(data_j, index.return = TRUE)\n#     sortclass <- mc$classification[sortdata$ix]\n#     ind1 <-which(sortclass == 1)\n#     ind2 <-which(sortclass == 2)\n#     len_ind1 <- length(ind1)\n#     len_ind2 <- length(ind2)\n#     length_sortclass <- length(sortclass)\n#     if(length_sortclass>2)\n#     {\n#       if(sortclass[1] == sortclass[length_sortclass])\n#       {\n#         if(sortclass[1] == 1)\n#         {\n#           ma <- max(sortdata$x[ind2])\n#           mi <- min(sortdata$x[ind2])\n#           ind_sup <- which(sortdata$x > mi)\n#           ind_inf <- which(sortdata$x < ma)\n#           len_sup <- length(ind_sup)\n#           len_inf <- length(ind_inf)\n#           ind_merge <- which.min(c(len_inf,len_sup))\n#           if(ind_merge == 1)\n#           {\n#             sortclass[ind_inf] <- 2\n#           }\n#           else\n#           {\n#             sortclass[ind_sup] <- 2\n#           }\n#         }\n#         else\n#         {\n#           ma <- max(sortdata$x[ind1])\n#           mi <- min(sortdata$x[ind1])\n#           ind_sup <- which(sortdata$x > mi)\n#           ind_inf <- which(sortdata$x < ma) \n#           len_sup <- length(ind_sup)\n#           len_inf <- length(ind_inf)   \n#           ind_merge <- which.min(c(len_inf, len_sup))\n#           if(ind_merge == 1)\n#           {\n#             sortclass[ind_inf] <- 1\n#           }\n#           else\n#           {\n#             sortclass[ind_sup] <- 1\n#           }\n#         }\n#       }\n#       sortclass <- sortclass[match(data_j, sortdata$x)]\n#       ind1 <-which(sortclass == 1)\n#       ind2 <-which(sortclass == 2)\n#     }\n#     \n#     #     col_ <- rep(1, nrow(data))\n#     #     col_[ind2] <- 2\n#     #     plot(data_j, rep(1,n), col = col_)\n#     \n#     \n#     #     if(length(ind1) == 1 | length(ind2) == 1){\n#     #       flag_uni <- 1\n#     #     }\n#     if(length(ind1) < minleaf | length(ind2) < minleaf){\n#       flag_uni <- 1\n#     }\n#     data1 <- data_j[ind1]\n#     data2 <- data_j[ind2]\n#     par <- list()\n#     par$mu[[1]] <- mean(data1)\n#     par$mu[[2]] <- mean(data2)\n#     #     par$mu[[1]] <- mc$parameters$mean[1]\n#     #     par$mu[[2]] <- mc$parameters$mean[2]\n#     \n#     par$Sigma[[1]] <- var(data1)\n#     par$Sigma[[2]] <- var(data2)\n#     if(!flag_uni){\n#       if( !par$Sigma[[1]] | !par$Sigma[[1]] \n#           |!par$Sigma[[2]] | !par$Sigma[[2]]\n#           | is.nan(par$Sigma[[1]]) | is.nan(par$Sigma[[1]])\n#           | is.nan(par$Sigma[[2]]) | is.nan(par$Sigma[[2]])\n#           | is.na(par$Sigma[[1]])  | is.na(par$Sigma[[1]])\n#           | is.na(par$Sigma[[2]])  | is.na(par$Sigma[[2]])){\n#         flag_dir <- 1\n#       }\n#     }\n#     if(flag_uni | flag_dir){\n#       #             plot(data_j,mvnpdfC(data_j,mu,Sigma,FALSE), cex=0.1)\n#       mark_not_dis <- append(mark_not_dis, j)\n#     }\n#     else{\n#       #       lik_uni <- mvnpdfC(data_j,mu,Sigma,TRUE)\n#       #       browser()\n#       icl_uni <- icl(mc_uni)\n#       icl_mix <- icl(mc)\n#       \n#       #             icl_uni <- mc_uni$bic\n#       #             icl_mix <- mc$bic\n#       \n#       \n#       #       browser()     \n#       #             mc <- Mclust(data_j, 2, modelNames = \"V\")\n#       #             \n#       #             ind1 <-which(mc$classification == 1)\n#       #             ind2 <-which(mc$classification == 2)\n#       #             col_ <- rep(1, nrow(data))\n#       #             col_[ind2] <- 2\n#       #             plot(data_j, rep(1,n), col = col_)\n#       #             plot(density(data_j))\n#       #             \n#       \n#       \n#       \n#       flag_uni <- 0\n#       thres <- 0.25\n#       if(length(which(!data_j))){\n#         #                 browser()\n#         if(length(which(!data_j)) > length(data_j)*thres){\n#           flag_uni <- 1\n#         }\n#       }\n#       if(icl_uni > icl_mix | flag_uni){\n#         mark_not_dis <- append(mark_not_dis, j)\n#       }\n#       else{\n#         if(par$mu[[1]] > par$mu[[2]]){\n#           #           browser()\n#           label <- mc$classification\n#           label[ind1] <- 1\n#           label[ind2] <- 0\n#         }\n#         else{\n#           label <- mc$classification\n#           label[ind1] <- 0\n#           label[ind2] <- 1\n#         }\n#         Ent_K2 <- icl_mix\n#         lve <- length(ResIcl)\n#         if(!lve){\n#           son$G <-  indices[which(label == 0)]\n#           son$D <-  indices[which(label == 1)]\n#         } \n#         else {\n#           if(ResIcl[lve] < Ent_K2){\n#             son$G <-  indices[which(label == 0)]\n#             son$D <-  indices[which(label == 1)]\n#           }\n#         }\n#         ResIcl <-  append(ResIcl, Ent_K2)\n#         ind_marker <- append(ind_marker,j)\n#       }\n#       \n#     }\n#   }\n#   if (!length(ind_marker)){\n#     return(list(\"entropie\"=NULL,\"ind\"=NULL,\"mark_not_dis\"=mark_not_dis,\n#                 \"son\" = NULL))\n#   }\n#   else if(length(ind_marker)==1){\n#     return(list(\"entropie\"=ResIcl,\"ind\"=ind_marker,\"mark_not_dis\"=mark_not_dis,\n#                 \"son\" = son))\n#   }\n#   else{\n#     res <- cbind(ResIcl, ind_marker)\n#     res <- res[order(res[,1],decreasing = TRUE),]\n#     return(list(\"entropie\"=res[,1],\"ind\"=res[,2],\"mark_not_dis\"=mark_not_dis,\n#                 \"son\" = son))\n#   }\n# }\n\n\n# EmIcl <- function(data, indices,minleaf,level, ancestry){\n#   mclust.options(warn=FALSE)  # TODO\n#   if(!is.null(ancestry$data))\n#   {\n#     #     if(level == 2){browser()}\n#     ancestordata <- ancestry$data \n#     ancestormarker <- ancestry$marker \n#     mcancestor <- Mclust(ancestordata, 2)\n#     sortdata_ <- sort(ancestordata, index.return = TRUE)\n#     sortclass_ <- mcancestor$classification[sortdata_$ix]\n#     ind1_ <-which(sortclass_ == 1)\n#     ind2_ <-which(sortclass_ == 2)\n#     len_ind1_ <- length(ind1_)\n#     len_ind2_ <- length(ind2_)\n#     length_sortclass_ <- length(sortclass_)\n#     if(length_sortclass_>2)\n#     {\n#       if(sortclass_[1] == sortclass_[length_sortclass_])\n#       {\n#         if(sortclass_[1] == 1)\n#         {\n#           ma_ <- max(sortdata_$x[ind2_])\n#           mi_ <- min(sortdata_$x[ind2_])\n#           ind_sup_ <- which(sortdata_$x > mi_)\n#           ind_inf_ <- which(sortdata_$x < ma_)\n#           len_sup_ <- length(ind_sup_)\n#           len_inf_ <- length(ind_inf_)\n#           ind_merge_ <- which.min(c(len_inf_,len_sup_))\n#           if(ind_merge_ == 1)\n#           {\n#             sortclass_[ind_inf_] <- 2\n#           }\n#           else\n#           {\n#             sortclass_[ind_sup_] <- 2\n#           }\n#         }\n#         else\n#         {\n#           ma_ <- max(sortdata_$x[ind1_])\n#           mi_ <- min(sortdata_$x[ind1_])\n#           ind_sup_ <- which(sortdata_$x > mi_)\n#           ind_inf_ <- which(sortdata_$x < ma_) \n#           len_sup_ <- length(ind_sup_)\n#           len_inf_ <- length(ind_inf_)   \n#           ind_merge_ <- which.min(c(len_inf_, len_sup_))\n#           if(ind_merge_ == 1)\n#           {\n#             sortclass_[ind_inf_] <- 1\n#           }\n#           else\n#           {\n#             sortclass_[ind_sup_] <- 1\n#           }\n#         }\n#       }\n#       sortclass_ <- sortclass_[match(ancestordata, sortdata_$x)]\n#       ind1 <-which(sortclass_ == 1)\n#       ind2 <-which(sortclass_ == 2)\n#       \n#       mu1ancestor <- mean(ancestordata[ind1])\n#       mu2ancestor <- mean(ancestordata[ind2])\n#       indmuancestor <- which.max(c(mu1ancestor, mu2ancestor))\n#       mudoublepositif <- c(mu1ancestor, mu2ancestor)[indmuancestor]\n#     } \n#   }\n#   \n#   data <- as.matrix(data)\n#   p <- ncol(data)\n#   n <- nrow(data)\n#   Minleaf <- 5\n#   if(n <= Minleaf | n < minleaf){\n#     mark_not_dis <- 1:p\n#     return(list(\"entropie\"=NULL,\"ind\"=NULL,\"mark_not_dis\"=mark_not_dis,\n#                 \"son\" = NULL))\n#   }\n#   ResIcl <- c()\n#   son <- list()\n#   ind_marker <- c()\n#   mark_not_dis <- c()\n#   \n#   #   if(level <= 5)\n#   #   {\n#   #     if(level==1){indCD3 <- which(colnames(data) == \"CD3\")}\n#   #     else if(level==2){indCD3 <- which(colnames(data) == \"CD4\")}\n#   #     else if(level==3){indCD3 <- which(colnames(data) == \"CD8\")}\n#   #     else if(level==4){indCD3 <- which(colnames(data) == \"CD45\")}\n#   #     else if(level==5){indCD3 <- which(colnames(data) == \"CD27\")}\n#   #     data_j <- data[,indCD3] \n#   #     mu <- mean(data_j)\n#   #     Sigma <- var(data_j)\n#   #     \n#   #     mc_uni <- Mclust(data_j, 1)\n#   #     \n#   #     # mc_uni <- Mclust(data_j, 1) \n#   #     flag_uni <- 0\n#   #     flag_dir <- 0\n#   #     #     mc <- Mclust(data_j, 2, modelNames = \"V\")\n#   #     \n#   #     mc <- Mclust(data_j, 2)\n#   #     \n#   #     #     \n#   #     #         ind1 <-which(mc$classification == 1)\n#   #     #         ind2 <-which(mc$classification == 2)\n#   #     \n#   #     sortdata <- sort(data_j, index.return = TRUE)\n#   #     sortclass <- mc$classification[sortdata$ix]\n#   #     ind1 <-which(sortclass == 1)\n#   #     ind2 <-which(sortclass == 2)\n#   #     len_ind1 <- length(ind1)\n#   #     len_ind2 <- length(ind2)\n#   #     length_sortclass <- length(sortclass)\n#   #     if(length_sortclass>2)\n#   #     {\n#   #       if(sortclass[1] == sortclass[length_sortclass])\n#   #       {\n#   #         if(sortclass[1] == 1)\n#   #         {\n#   #           ma <- max(sortdata$x[ind2])\n#   #           mi <- min(sortdata$x[ind2])\n#   #           ind_sup <- which(sortdata$x > mi)\n#   #           ind_inf <- which(sortdata$x < ma)\n#   #           len_sup <- length(ind_sup)\n#   #           len_inf <- length(ind_inf)\n#   #           ind_merge <- which.min(c(len_inf,len_sup))\n#   #           if(ind_merge == 1)\n#   #           {\n#   #             sortclass[ind_inf] <- 2\n#   #           }\n#   #           else\n#   #           {\n#   #             sortclass[ind_sup] <- 2\n#   #           }\n#   #         }\n#   #         else\n#   #         {\n#   #           ma <- max(sortdata$x[ind1])\n#   #           mi <- min(sortdata$x[ind1])\n#   #           ind_sup <- which(sortdata$x > mi)\n#   #           ind_inf <- which(sortdata$x < ma) \n#   #           len_sup <- length(ind_sup)\n#   #           len_inf <- length(ind_inf)   \n#   #           ind_merge <- which.min(c(len_inf, len_sup))\n#   #           if(ind_merge == 1)\n#   #           {\n#   #             sortclass[ind_inf] <- 1\n#   #           }\n#   #           else\n#   #           {\n#   #             sortclass[ind_sup] <- 1\n#   #           }\n#   #         }\n#   #       }\n#   #       sortclass <- sortclass[match(data_j, sortdata$x)]\n#   #       ind1 <-which(sortclass == 1)\n#   #       ind2 <-which(sortclass == 2)\n#   #     }\n#   #     data1 <- data_j[ind1]\n#   #     data2 <- data_j[ind2]\n#   #     par <- list()\n#   #     par$mu[[1]] <- mean(data1)\n#   #     par$mu[[2]] <- mean(data2)\n#   #     #     par$mu[[1]] <- mc$parameters$mean[1]\n#   #     #     par$mu[[2]] <- mc$parameters$mean[2]\n#   #     \n#   #     par$Sigma[[1]] <- var(data1)\n#   #     par$Sigma[[2]] <- var(data2)\n#   #     \n#   #     \n#   #     icl_mix <- icl(mc)\n#   #     \n#   #     \n#   #     if(par$mu[[1]] > par$mu[[2]]){\n#   #       #           browser()\n#   #       label <- mc$classification\n#   #       label[ind1] <- 1\n#   #       label[ind2] <- 0\n#   #     }\n#   #     else{\n#   #       label <- mc$classification\n#   #       label[ind1] <- 0\n#   #       label[ind2] <- 1\n#   #     }\n#   #     Ent_K2 <- icl_mix\n#   #     lve <- length(ResIcl)\n#   #     if(!lve){\n#   #       son$G <-  indices[which(label == 0)]\n#   #       son$D <-  indices[which(label == 1)]\n#   #     } \n#   #     else {\n#   #       if(ResIcl[lve] < Ent_K2){\n#   #         son$G <-  indices[which(label == 0)]\n#   #         son$D <-  indices[which(label == 1)]\n#   #       }\n#   #     }\n#   #     ResIcl <-  append(ResIcl, Ent_K2)\n#   #     \n#   #     \n#   #     return(list(\"entropie\"=ResIcl,\"ind\"=indCD3,\"mark_not_dis\"=c(1:p)[-c(indCD3)],\n#   #                 \"son\" = son))\n#   #   }\n#   \n#   #   else\n#   #   {\n#   for(j in 1:p){\n#     \n#     data_j <- data[,j]\n#     mu <- mean(data_j)\n#     Sigma <- var(data_j)\n#     \n#     mc_uni <- Mclust(data_j, 1)\n#     \n#     # mc_uni <- Mclust(data_j, 1) \n#     flag_uni <- 0\n#     flag_dir <- 0\n#     \n#     mc <- Mclust(data_j, 2)\n#     if(length(table(mc$classification)) == 1)\n#     {\n#       mc <- Mclust(data_j, 2, modelNames = \"E\")\n#     }\n#     \n#     #     \n#     #         ind1 <-which(mc$classification == 1)\n#     #         ind2 <-which(mc$classification == 2)\n#     \n#     sortdata <- sort(data_j, index.return = TRUE)\n#     sortclass <- mc$classification[sortdata$ix]\n#     ind1 <-which(sortclass == 1)\n#     ind2 <-which(sortclass == 2)\n#     len_ind1 <- length(ind1)\n#     len_ind2 <- length(ind2)\n#     length_sortclass <- length(sortclass)\n#     if(length_sortclass>2)\n#     {\n#       if(sortclass[1] == sortclass[length_sortclass])\n#       {\n#         if(sortclass[1] == 1)\n#         {\n#           \n#           ma <- max(sortdata$x[ind2])\n#           \n#           if(is.infinite(ma)){browser()}\n#           mi <- min(sortdata$x[ind2])\n#           ind_sup <- which(sortdata$x > mi)\n#           ind_inf <- which(sortdata$x < ma)\n#           len_sup <- length(ind_sup)\n#           len_inf <- length(ind_inf)\n#           ind_merge <- which.min(c(len_inf,len_sup))\n#           if(ind_merge == 1)\n#           {\n#             sortclass[ind_inf] <- 2\n#           }\n#           else\n#           {\n#             sortclass[ind_sup] <- 2\n#           }\n#         }\n#         else\n#         {\n#           ma <- max(sortdata$x[ind1])\n#           mi <- min(sortdata$x[ind1])\n#           ind_sup <- which(sortdata$x > mi)\n#           ind_inf <- which(sortdata$x < ma) \n#           len_sup <- length(ind_sup)\n#           len_inf <- length(ind_inf)   \n#           ind_merge <- which.min(c(len_inf, len_sup))\n#           if(ind_merge == 1)\n#           {\n#             sortclass[ind_inf] <- 1\n#           }\n#           else\n#           {\n#             sortclass[ind_sup] <- 1\n#           }\n#         }\n#       }\n#       sortclass <- sortclass[match(data_j, sortdata$x)]\n#       ind1 <-which(sortclass == 1)\n#       ind2 <-which(sortclass == 2)\n#     }\n#     \n#     #     col_ <- rep(1, nrow(data))\n#     #     col_[ind2] <- 2\n#     #     plot(data_j, rep(1,n), col = col_)\n#     \n#     \n#     #     if(length(ind1) == 1 | length(ind2) == 1){\n#     #       flag_uni <- 1\n#     #     }\n#     if(length(ind1) < minleaf | length(ind2) < minleaf){\n#       flag_uni <- 1\n#     }\n#     data1 <- data_j[ind1]\n#     data2 <- data_j[ind2]\n#     par <- list()\n#     par$mu[[1]] <- mean(data1)\n#     par$mu[[2]] <- mean(data2)\n#     #     par$mu[[1]] <- mc$parameters$mean[1]\n#     #     par$mu[[2]] <- mc$parameters$mean[2]\n#     \n#     par$Sigma[[1]] <- var(data1)\n#     par$Sigma[[2]] <- var(data2)\n#     if(!flag_uni){\n#       if( !par$Sigma[[1]] | !par$Sigma[[1]] \n#           |!par$Sigma[[2]] | !par$Sigma[[2]]\n#           | is.nan(par$Sigma[[1]]) | is.nan(par$Sigma[[1]])\n#           | is.nan(par$Sigma[[2]]) | is.nan(par$Sigma[[2]])\n#           | is.na(par$Sigma[[1]])  | is.na(par$Sigma[[1]])\n#           | is.na(par$Sigma[[2]])  | is.na(par$Sigma[[2]])){\n#         flag_dir <- 1\n#       }\n#     }\n#     if(flag_uni | flag_dir){\n#       #             plot(data_j,mvnpdfC(data_j,mu,Sigma,FALSE), cex=0.1)\n#       mark_not_dis <- append(mark_not_dis, j)\n#     }\n#     else{\n#       #       lik_uni <- mvnpdfC(data_j,mu,Sigma,TRUE)\n#       #       browser()\n#       icl_uni <- icl(mc_uni)\n#       icl_mix <- icl(mc)\n#       #         print(abs(icl_uni / n) - abs(icl_mix / n))\n#       diff <- abs(icl_uni - icl_mix)\n#       #         print(icl_mix / n)\n#       #         print(abs(log(icl_uni) - log(icl_mix)))\n#       \n#       #             icl_uni <- mc_uni$bic\n#       #             icl_mix <- mc$bic\n#       \n#       \n#       #       browser()     \n#       #             mc <- Mclust(data_j, 2, modelNames = \"V\")\n#       #             \n#       #             ind1 <-which(mc$classification == 1)\n#       #             ind2 <-which(mc$classification == 2)\n#       #             col_ <- rep(1, nrow(data))\n#       #             col_[ind2] <- 2\n#       #             plot(data_j, rep(1,n), col = col_)\n#       #             plot(density(data_j))\n#       #             \n#       \n#       \n#       \n#       flag_uni <- 0\n#       thres <- 0.25\n#       if(length(which(!data_j))){\n#         #                 browser()\n#         if(length(which(!data_j)) > length(data_j)*thres){\n#           flag_uni <- 1\n#         }\n#       }\n#       if(icl_uni > icl_mix | flag_uni ){\n#         #         if(icl_uni > icl_mix | flag_uni | ((diff/n)<0.05)){\n#         mark_not_dis <- append(mark_not_dis, j)\n#       }\n#       else{\n#         if(par$mu[[1]] > par$mu[[2]]){\n#           #           browser()\n#           label <- mc$classification\n#           label[ind1] <- 1\n#           label[ind2] <- 0\n#         }\n#         else{\n#           label <- mc$classification\n#           label[ind1] <- 0\n#           label[ind2] <- 1\n#         }\n#         #           Ent_K2 <- icl_mix\n#         Ent_K2 <- diff\n#         lve <- length(ResIcl)\n#         if(!lve){\n#           son$G <-  indices[which(label == 0)]\n#           son$D <-  indices[which(label == 1)]\n#         } \n#         else {\n#           if(ResIcl[lve] < Ent_K2){\n#             son$G <-  indices[which(label == 0)]\n#             son$D <-  indices[which(label == 1)]\n#           }\n#         }\n#         \n#         #         if(!is.null(ancestry))\n#         #         {\n#         #           flagdoublepositif <- 0\n#         #           parmu <- c(par$mu[[1]], par$mu[[2]])\n#         #           if(parmu[which.max(parmu)] <= mudoublepositif)\n#         #             \n#         #           {\n#         #             flagdoublepositif <- 1\n#         #           }\n#         #           if(flagdoublepositif)\n#         #           {\n#         #             mark_not_dis <- append(mark_not_dis, j)\n#         #           }\n#         #           else\n#         #           {\n#         #             ResIcl <-  append(ResIcl, Ent_K2)\n#         #             ind_marker <- append(ind_marker,j)  \n#         #           }\n#         #         }\n#         #         else\n#         #         {\n#         #           ResIcl <-  append(ResIcl, Ent_K2)\n#         #           ind_marker <- append(ind_marker,j)  \n#         #         }\n#         ResIcl <-  append(ResIcl, Ent_K2)\n#         ind_marker <- append(ind_marker,j)\n#       }\n#       \n#     }\n#   }\n#   if (!length(ind_marker)){\n#     return(list(\"entropie\"=NULL,\"ind\"=NULL,\"mark_not_dis\"=mark_not_dis,\n#                 \"son\" = NULL))\n#   }\n#   else if(length(ind_marker)==1){\n#     \n#     \n#     \n#     #     if(!is.null(ancestry$data))\n#     #     {\n#     #       \n#     #       \n#     #       data_j <- data[,ind_marker]\n#     #       mc <- Mclust(data_j, 2)\n#     #       if(length(table(mc$classification)) == 1)\n#     #       {\n#     #         mc <- Mclust(data_j, 2, modelNames = \"E\")\n#     #       }\n#     #       \n#     #       #     \n#     #       #         ind1 <-which(mc$classification == 1)\n#     #       #         ind2 <-which(mc$classification == 2)\n#     #       \n#     #       sortdata <- sort(data_j, index.return = TRUE)\n#     #       sortclass <- mc$classification[sortdata$ix]\n#     #       ind1 <-which(sortclass == 1)\n#     #       ind2 <-which(sortclass == 2)\n#     #       len_ind1 <- length(ind1)\n#     #       len_ind2 <- length(ind2)\n#     #       length_sortclass <- length(sortclass)\n#     #       if(length_sortclass>2)\n#     #       {\n#     #         if(sortclass[1] == sortclass[length_sortclass])\n#     #         {\n#     #           if(sortclass[1] == 1)\n#     #           {\n#     #             ma <- max(sortdata$x[ind2])\n#     #             mi <- min(sortdata$x[ind2])\n#     #             ind_sup <- which(sortdata$x > mi)\n#     #             ind_inf <- which(sortdata$x < ma)\n#     #             len_sup <- length(ind_sup)\n#     #             len_inf <- length(ind_inf)\n#     #             ind_merge <- which.min(c(len_inf,len_sup))\n#     #             if(ind_merge == 1)\n#     #             {\n#     #               sortclass[ind_inf] <- 2\n#     #             }\n#     #             else\n#     #             {\n#     #               sortclass[ind_sup] <- 2\n#     #             }\n#     #           }\n#     #           else\n#     #           {\n#     #             ma <- max(sortdata$x[ind1])\n#     #             mi <- min(sortdata$x[ind1])\n#     #             ind_sup <- which(sortdata$x > mi)\n#     #             ind_inf <- which(sortdata$x < ma) \n#     #             len_sup <- length(ind_sup)\n#     #             len_inf <- length(ind_inf)   \n#     #             ind_merge <- which.min(c(len_inf, len_sup))\n#     #             if(ind_merge == 1)\n#     #             {\n#     #               sortclass[ind_inf] <- 1\n#     #             }\n#     #             else\n#     #             {\n#     #               sortclass[ind_sup] <- 1\n#     #             }\n#     #           }\n#     #         }\n#     #         sortclass <- sortclass[match(data_j, sortdata$x)]\n#     #         ind1 <-which(sortclass == 1)\n#     #         ind2 <-which(sortclass == 2)\n#     #       }\n#     #       \n#     #       parmu <-c(mean(data[ind1,ind_marker]),mean(data[ind2,ind_marker]))\n#     #       \n#     #       \n#     #       indparmu <- which.max(parmu)\n#     #       \n#     #       if(indparmu == 1){browser()} # TODO\n#     #     \n#     #       \n#     #       flagdoublepositif <- 0\n#     #       if((parmu[indparmu] <= mudoublepositif) & (length(ind2)<length(ind1)))\n#     #         \n#     #       {\n#     #         flagdoublepositif <- 1\n#     #       }\n#     #       if(flagdoublepositif)\n#     #       {\n#     #         return(list(\"entropie\"=ResIcl,\"ind\"=NULL,\n#     #                     \"mark_not_dis\"=c(ind_marker,mark_not_dis),\n#     #                     \"son\" = son))\n#     #       }\n#     return(list(\"entropie\"=ResIcl,\"ind\"=ind_marker,\"mark_not_dis\"=mark_not_dis,\n#                 \"son\" = son))\n#     #     }\n#   }\n#   else{\n#     res_ <- cbind(ResIcl, ind_marker)\n#     res_ <- res_[order(res_[,1],decreasing = TRUE),]\n#     res <- res_\n#     \n#     if(!is.null(ancestry$data))\n#     {\n#       rmdouble <- c()\n#       for(ii in 1:nrow(res))\n#       {\n#         ind_marker <- res[ii,2]  \n#         data_j <- data[,ind_marker]\n#         mc <- Mclust(data_j, 2)\n#         if(length(table(mc$classification)) == 1)\n#         {\n#           mc <- Mclust(data_j, 2, modelNames = \"E\")\n#         }\n#         \n#         \n#         sortdata <- sort(data_j, index.return = TRUE)\n#         sortclass <- mc$classification[sortdata$ix]\n#         ind1 <-which(sortclass == 1)\n#         ind2 <-which(sortclass == 2)\n#         len_ind1 <- length(ind1)\n#         len_ind2 <- length(ind2)\n#         length_sortclass <- length(sortclass)\n#         if(length_sortclass>2)\n#         {\n#           if(sortclass[1] == sortclass[length_sortclass])\n#           {\n#             if(sortclass[1] == 1)\n#             {\n#               ma <- max(sortdata$x[ind2])\n#               mi <- min(sortdata$x[ind2])\n#               ind_sup <- which(sortdata$x > mi)\n#               ind_inf <- which(sortdata$x < ma)\n#               len_sup <- length(ind_sup)\n#               len_inf <- length(ind_inf)\n#               ind_merge <- which.min(c(len_inf,len_sup))\n#               if(ind_merge == 1)\n#               {\n#                 sortclass[ind_inf] <- 2\n#               }\n#               else\n#               {\n#                 sortclass[ind_sup] <- 2\n#               }\n#             }\n#             else\n#             {\n#               ma <- max(sortdata$x[ind1])\n#               mi <- min(sortdata$x[ind1])\n#               ind_sup <- which(sortdata$x > mi)\n#               ind_inf <- which(sortdata$x < ma) \n#               len_sup <- length(ind_sup)\n#               len_inf <- length(ind_inf)   \n#               ind_merge <- which.min(c(len_inf, len_sup))\n#               if(ind_merge == 1)\n#               {\n#                 sortclass[ind_inf] <- 1\n#               }\n#               else\n#               {\n#                 sortclass[ind_sup] <- 1\n#               }\n#             }\n#           }\n#           sortclass <- sortclass[match(data_j, sortdata$x)]\n#           ind1 <-which(sortclass == 1)\n#           ind2 <-which(sortclass == 2)\n#         }\n#         \n#         parmu <-c(mean(data[ind1,ind_marker]),mean(data[ind2,ind_marker])) \n#         flagdoublepositif <- 0\n#         indparmu <- which.max(parmu)\n#       \n#         if(indparmu == 1)\n#         {\n#           ind1old <- ind1\n#           ind2old <- ind2\n#           ind1 <- ind2old\n#           ind2 <- ind1old\n#           parmu <-c(mean(data[ind1,ind_marker]),mean(data[ind2,ind_marker]))\n#           indparmu <- which.max(parmu)\n#         } \n#         \n#         \n#         \n#         if((parmu[indparmu] <= mudoublepositif) & (length(ind2)<length(ind1)))\n#         {\n#           flagdoublepositif <- 1\n#         }\n#         if(flagdoublepositif)\n#         {\n#           mark_not_dis <- append(mark_not_dis,ind_marker)\n#           \n#           rmdouble <- append(rmdouble, ii)\n#           \n#         }\n#       }\n#       \n#       if(length(rmdouble)==nrow(res))\n#       {\n#         return(list(\"entropie\"=NULL,\"ind\"=NULL,\n#                     \"mark_not_dis\"=mark_not_dis,\n#                     \"son\" = son))\n#       }\n#       else if(length(rmdouble) == (nrow(res)-1) )\n#       {\n#         indpo <- !res_[,2]%in%rmdouble\n#         \n#         return(list(\"entropie\"=res[indpo,1],\n#                     \"ind\"=res[indpo,2],\"mark_not_dis\"=mark_not_dis,\n#                     \"son\" = son))\n#         \n#       }\n#       else if (length(rmdouble))\n#       {\n#         \n#         return(list(\"entropie\"=res[-c(rmdouble),1],\n#                     \"ind\"=res[-c(rmdouble),2],\"mark_not_dis\"=mark_not_dis,\n#                     \"son\" = son))\n#       }\n#     } \n#     return(list(\"entropie\"=res_[,1],\"ind\"=res_[,2],\"mark_not_dis\"=mark_not_dis,\n#                 \"son\" = son))\n#   }\n# }\n\n\n\n\nEmIcl <- function(data, indices,minleaf,level){\n  mclust.options(warn=FALSE)\n  data <- as.matrix(data)\n  p <- ncol(data)\n  n <- nrow(data)\n  Minleaf <- 5\n  if(n <= Minleaf | n < minleaf){\n    mark_not_dis <- 1:p\n    return(list(\"entropie\"=NULL,\"ind\"=NULL,\"mark_not_dis\"=mark_not_dis,\n                \"son\" = NULL))\n  }\n  ResIcl <- c()\n  mu1 <- c()\n  mu2 <- c()\n  Var1 <- c()\n  Var2 <- c()\n  pi1 <- c()\n  pi2 <- c()\n  son <- list()\n  ind_marker <- c()\n  mark_not_dis <- c()\n  \n  #   if(level <= 5)\n  #   {\n  #     if(level==1){indCD3 <- which(colnames(data) == \"CD3\")}\n  #     else if(level==2){indCD3 <- which(colnames(data) == \"CD4\")}\n  #     else if(level==3){indCD3 <- which(colnames(data) == \"CD8\")}\n  #     else if(level==4){indCD3 <- which(colnames(data) == \"CD45\")}\n  #     else if(level==5){indCD3 <- which(colnames(data) == \"CD27\")}\n  #     data_j <- data[,indCD3] \n  #     mu <- mean(data_j)\n  #     Sigma <- var(data_j)\n  #     \n  #     mc_uni <- Mclust(data_j, 1)\n  #     \n  #     # mc_uni <- Mclust(data_j, 1) \n  #     flag_uni <- 0\n  #     flag_dir <- 0\n  #     #     mc <- Mclust(data_j, 2, modelNames = \"V\")\n  #     \n  #     mc <- Mclust(data_j, 2)\n  #     \n  #     #     \n  #     #         ind1 <-which(mc$classification == 1)\n  #     #         ind2 <-which(mc$classification == 2)\n  #     \n  #     sortdata <- sort(data_j, index.return = TRUE)\n  #     sortclass <- mc$classification[sortdata$ix]\n  #     ind1 <-which(sortclass == 1)\n  #     ind2 <-which(sortclass == 2)\n  #     len_ind1 <- length(ind1)\n  #     len_ind2 <- length(ind2)\n  #     length_sortclass <- length(sortclass)\n  #     if(length_sortclass>2)\n  #     {\n  #       if(sortclass[1] == sortclass[length_sortclass])\n  #       {\n  #         if(sortclass[1] == 1)\n  #         {\n  #           ma <- max(sortdata$x[ind2])\n  #           mi <- min(sortdata$x[ind2])\n  #           ind_sup <- which(sortdata$x > mi)\n  #           ind_inf <- which(sortdata$x < ma)\n  #           len_sup <- length(ind_sup)\n  #           len_inf <- length(ind_inf)\n  #           ind_merge <- which.min(c(len_inf,len_sup))\n  #           if(ind_merge == 1)\n  #           {\n  #             sortclass[ind_inf] <- 2\n  #           }\n  #           else\n  #           {\n  #             sortclass[ind_sup] <- 2\n  #           }\n  #         }\n  #         else\n  #         {\n  #           ma <- max(sortdata$x[ind1])\n  #           mi <- min(sortdata$x[ind1])\n  #           ind_sup <- which(sortdata$x > mi)\n  #           ind_inf <- which(sortdata$x < ma) \n  #           len_sup <- length(ind_sup)\n  #           len_inf <- length(ind_inf)   \n  #           ind_merge <- which.min(c(len_inf, len_sup))\n  #           if(ind_merge == 1)\n  #           {\n  #             sortclass[ind_inf] <- 1\n  #           }\n  #           else\n  #           {\n  #             sortclass[ind_sup] <- 1\n  #           }\n  #         }\n  #       }\n  #       sortclass <- sortclass[match(data_j, sortdata$x)]\n  #       ind1 <-which(sortclass == 1)\n  #       ind2 <-which(sortclass == 2)\n  #     }\n  #     data1 <- data_j[ind1]\n  #     data2 <- data_j[ind2]\n  #     par <- list()\n  #     par$mu[[1]] <- mean(data1)\n  #     par$mu[[2]] <- mean(data2)\n  #     #     par$mu[[1]] <- mc$parameters$mean[1]\n  #     #     par$mu[[2]] <- mc$parameters$mean[2]\n  #     \n  #     par$Sigma[[1]] <- var(data1)\n  #     par$Sigma[[2]] <- var(data2)\n  #     \n  #     \n  #     icl_mix <- icl(mc)\n  #     \n  #     \n  #     if(par$mu[[1]] > par$mu[[2]]){\n  #       #           browser()\n  #       label <- mc$classification\n  #       label[ind1] <- 1\n  #       label[ind2] <- 0\n  #     }\n  #     else{\n  #       label <- mc$classification\n  #       label[ind1] <- 0\n  #       label[ind2] <- 1\n  #     }\n  #     Ent_K2 <- icl_mix\n  #     lve <- length(ResIcl)\n  #     if(!lve){\n  #       son$G <-  indices[which(label == 0)]\n  #       son$D <-  indices[which(label == 1)]\n  #     } \n  #     else {\n  #       if(ResIcl[lve] < Ent_K2){\n  #         son$G <-  indices[which(label == 0)]\n  #         son$D <-  indices[which(label == 1)]\n  #       }\n  #     }\n  #     ResIcl <-  append(ResIcl, Ent_K2)\n  #     \n  #     \n  #     return(list(\"entropie\"=ResIcl,\"ind\"=indCD3,\"mark_not_dis\"=c(1:p)[-c(indCD3)],\n  #                 \"son\" = son))\n  #   }\n  \n  #   else\n  #   {\n  \n  for(j in 1:p){\n    \n    data_j <- data[,j]\n    mu <- mean(data_j)\n    Sigma <- var(data_j)\n    \n    mc_uni <- Mclust(data_j, 1)\n    \n    # mc_uni <- Mclust(data_j, 1) \n    flag_uni <- 0\n    flag_dir <- 0\n    #     mc <- Mclust(data_j, 2, modelNames = \"V\")\n    \n    mc <- Mclust(data_j, 2)\n    \n    #     \n    #         ind1 <-which(mc$classification == 1)\n    #         ind2 <-which(mc$classification == 2)\n    \n    sortdata <- sort(data_j, index.return = TRUE)\n    sortclass <- mc$classification[sortdata$ix]\n    ind1 <-which(sortclass == 1)\n    ind2 <-which(sortclass == 2)\n    len_ind1 <- length(ind1)\n    len_ind2 <- length(ind2)\n    length_sortclass <- length(sortclass)\n    if(length_sortclass>2)\n    {\n      if(sortclass[1] == sortclass[length_sortclass])\n      {\n        if(sortclass[1] == 1)\n        {\n          ma <- max(sortdata$x[ind2])\n          mi <- min(sortdata$x[ind2])\n          ind_sup <- which(sortdata$x > mi)\n          ind_inf <- which(sortdata$x < ma)\n          len_sup <- length(ind_sup)\n          len_inf <- length(ind_inf)\n          ind_merge <- which.min(c(len_inf,len_sup))\n          if(ind_merge == 1)\n          {\n            sortclass[ind_inf] <- 2\n          }\n          else\n          {\n            sortclass[ind_sup] <- 2\n          }\n        }\n        else\n        {\n          ma <- max(sortdata$x[ind1])\n          mi <- min(sortdata$x[ind1])\n          ind_sup <- which(sortdata$x > mi)\n          ind_inf <- which(sortdata$x < ma) \n          len_sup <- length(ind_sup)\n          len_inf <- length(ind_inf)   \n          ind_merge <- which.min(c(len_inf, len_sup))\n          if(ind_merge == 1)\n          {\n            sortclass[ind_inf] <- 1\n          }\n          else\n          {\n            sortclass[ind_sup] <- 1\n          }\n        }\n      }\n      sortclass <- sortclass[match(data_j, sortdata$x)]\n      ind1 <-which(sortclass == 1)\n      ind2 <-which(sortclass == 2)\n    }\n    \n    #     col_ <- rep(1, nrow(data))\n    #     col_[ind2] <- 2\n    #     plot(data_j, rep(1,n), col = col_)\n    \n    \n    #     if(length(ind1) == 1 | length(ind2) == 1){\n    #       flag_uni <- 1\n    #     }\n    if(length(ind1) < minleaf | length(ind2) < minleaf){\n      flag_uni <- 1\n    }\n    data1 <- data_j[ind1]\n    data2 <- data_j[ind2]\n    par <- list()\n    par$mu[[1]] <- mean(data1)\n    par$mu[[2]] <- mean(data2)\n    \n    #     par$mu[[1]] <- mc$parameters$mean[1]\n    #     par$mu[[2]] <- mc$parameters$mean[2]\n    \n    par$Sigma[[1]] <- var(data1)\n    par$Sigma[[2]] <- var(data2)\n    if(!flag_uni){\n      if( !par$Sigma[[1]] | !par$Sigma[[1]] \n          |!par$Sigma[[2]] | !par$Sigma[[2]]\n          | is.nan(par$Sigma[[1]]) | is.nan(par$Sigma[[1]])\n          | is.nan(par$Sigma[[2]]) | is.nan(par$Sigma[[2]])\n          | is.na(par$Sigma[[1]])  | is.na(par$Sigma[[1]])\n          | is.na(par$Sigma[[2]])  | is.na(par$Sigma[[2]])){\n        flag_dir <- 1\n      }\n    }\n    if(flag_uni | flag_dir){\n      #             plot(data_j,mvnpdfC(data_j,mu,Sigma,FALSE), cex=0.1)\n      mark_not_dis <- append(mark_not_dis, j)\n    }\n    else{\n      #       lik_uni <- mvnpdfC(data_j,mu,Sigma,TRUE)\n      #       browser()\n      icl_uni <- icl(mc_uni)\n      icl_mix <- icl(mc)\n      #         print(abs(icl_uni / n) - abs(icl_mix / n))\n      diff <- abs(icl_uni - icl_mix)\n      #         print(icl_mix / n)\n      #         print(abs(log(icl_uni) - log(icl_mix)))\n      \n      #             icl_uni <- mc_uni$bic\n      #             icl_mix <- mc$bic\n      \n      \n      #       browser()     \n      #             mc <- Mclust(data_j, 2, modelNames = \"V\")\n      #             \n      #             ind1 <-which(mc$classification == 1)\n      #             ind2 <-which(mc$classification == 2)\n      #             col_ <- rep(1, nrow(data))\n      #             col_[ind2] <- 2\n      #             plot(data_j, rep(1,n), col = col_)\n      #             plot(density(data_j))\n      #             \n      \n      \n      \n      flag_uni <- 0\n      thres <- 0.25\n      flagComp <- 0\n      if(length(which(!data_j))){\n        #                 browser()\n        if(length(which(!data_j)) > length(data_j)*thres){\n          flag_uni <- 1\n        }\n      }\n      if(icl_uni > icl_mix | flag_uni ){\n        #         if(icl_uni > icl_mix | flag_uni | ((diff/n)<0.05)){\n        mark_not_dis <- append(mark_not_dis, j)\n      }\n      else{\n        if(par$mu[[1]] > par$mu[[2]]){\n          #           browser()\n          flagComp <- 1\n          label <- mc$classification\n          label[ind1] <- 1\n          label[ind2] <- 0\n        }\n        else{\n          label <- mc$classification\n          label[ind1] <- 0\n          label[ind2] <- 1\n        }\n        #           Ent_K2 <- icl_mix\n        Ent_K2 <- diff/n\n        lve <- length(ResIcl)\n        if(!lve){\n          son$G <-  indices[which(label == 0)]\n          son$D <-  indices[which(label == 1)]\n        } \n        else {\n          if(ResIcl[lve] < Ent_K2){\n            son$G <-  indices[which(label == 0)]\n            son$D <-  indices[which(label == 1)]\n          }\n        }\n        ResIcl <-  append(ResIcl, Ent_K2)\n        if(flagComp)\n        {\n          mu1 <- append(mu1, mean(data2))\n          mu2 <- append(mu2, mean(data1))\n          Var1 <- append(Var1, var(data2))\n          Var2 <- append(Var2, var(data1))\n          pi1 <- append(pi1, length(data2)/length(data_j))\n          pi2 <- append(pi2, length(data1)/length(data_j))\n          ind_marker <- append(ind_marker,j)\n        }\n        else\n        {\n          mu1 <- append(mu1, mean(data1))\n          mu2 <- append(mu2, mean(data2))\n          Var1 <- append(Var1, var(data1))\n          Var2 <- append(Var2, var(data2))\n          pi1 <- append(pi1, length(data1)/length(data_j))\n          pi2 <- append(pi2, length(data2)/length(data_j))\n          ind_marker <- append(ind_marker,j)\n        }\n        \n      }\n      \n    }\n  }\n  if (!length(ind_marker)){\n    return(list(\"entropie\"=NULL,\"ind\"=NULL,\"mark_not_dis\"=mark_not_dis,\n                \"son\" = NULL, \"mu1\" = NULL, \n                \"mu2\" = NULL, \n                \"Var1\" = NULL, \n                \"Var2\" = NULL,\n                \"pi1\" = NULL,\n                \"pi2\" = NULL))\n  }\n  else if(length(ind_marker)==1){\n    return(list(\"entropie\"=ResIcl,\"ind\"=ind_marker,\"mark_not_dis\"=mark_not_dis,\n                \"son\" = son, \"mu1\" = mu1, \"mu2\" = mu2, \n                \"Var1\" = Var1, \"Var2\" = Var2, \"pi1\" = pi1,\n                \"pi2\" = pi2))\n  }\n  else{\n    res <- cbind(ResIcl, ind_marker, mu1, mu2, Var1, Var2, pi1, pi2)\n    res <- res[order(res[,1],decreasing = TRUE),]\n    return(list(\"entropie\"=res[,1],\"ind\"=res[,2],\"mark_not_dis\"=mark_not_dis,\n                \"son\" = son, \"mu1\"= res[1,3], \"mu2\"= res[1,4],\n                \"Var1\" = res[1,5], \"Var2\" = res[1,6],\n                \"pi1\"= res[1,7], \"pi2\" = res[1,8]))\n  }\n  #   }\n}\n\n\n\n\n\n\n\n\n\n\n",
    "created" : 1477131041316.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "963711844",
    "id" : "3CD62D53",
    "lastKnownWriteTime" : 1479035172,
    "last_content_update" : 1479035172380,
    "path" : "~/Cytometree/R/EmIcl.R",
    "project_path" : "R/EmIcl.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}